{
  "Load": {
    "prefix": "load",
    "body": [
      "Load\n\t${1:*}\n${2:// FROM or RESIDENT clause};"
    ],
    "description": "The LOAD statement loads fields from a file, from data defined in the script, from a previously loaded table, from a web page,\nfrom the result of a subsequent SELECT statement or by generating data automatically."
  },
  "Load Inline": {
    "prefix": "load inline",
    "body": [
      "Load * Inline [\n\t${1:Field1}, ${2:Field2}\n\t${3:value1}, ${4:value2}\n];"
    ],
    "description": "Script statement: LOAD INLINE - loads data defined directly in the script."
  },
  "Load Resident": {
    "prefix": "load resident",
    "body": [
      "Load\n\t${1:*}\nResident ${2:TableName}\n${3:// WHERE clause};"
    ],
    "description": "Script statement: LOAD RESIDENT - loads data from an already loaded table."
  },
  "Load From QVD": {
    "prefix": "load from qvd",
    "body": [
      "Load\n\t${1:*}\nFrom [${2:lib://path/file.qvd}]\n(qvd);"
    ],
    "description": "Script statement: LOAD FROM QVD - loads data from a QVD file."
  },
  "Load From CSV": {
    "prefix": "load from csv",
    "body": [
      "Load\n\t${1:*}\nFrom [${2:lib://path/file.csv}]\n(txt, codepage is 65001, embedded labels, delimiter is ',', msq);"
    ],
    "description": "Script statement: LOAD FROM CSV - loads data from a CSV file with UTF-8 encoding."
  },
  "Mapping Load Inline": {
    "prefix": "mapping load inline",
    "body": [
      "${1:MapName}:\nMapping Load * Inline [\n\t${2:Key}, ${3:Value}\n\t${4:key1}, ${5:val1}\n];"
    ],
    "description": "The mapping prefix is used to create a mapping table that can be used to, for example, replacing field values and field names during script execution."
  },
  "Mapping Load Resident": {
    "prefix": "mapping load resident",
    "body": [
      "${1:MapName}:\nMapping Load\n\t${2:KeyField},\n\t${3:ValueField}\nResident ${4:TableName};"
    ],
    "description": "The mapping prefix is used to create a mapping table that can be used to, for example, replacing field values and field names during script execution."
  },
  "Select": {
    "prefix": "select",
    "body": [
      "SELECT\n\t${1:*}\nFROM ${2:table_name};"
    ],
    "description": "Script statement: SELECT - loads data using SQL SELECT from a database."
  },
  "Let": {
    "prefix": "let",
    "body": [
      "Let ${1:vVariable} = ${2:expression};"
    ],
    "description": "The let statement is a complement to the set statement, used for defining script variables. The let statement, in opposition to\nthe set statement, evaluates the expression on the right side of the ' =' before it is assigned to the variable."
  },
  "Set": {
    "prefix": "set",
    "body": [
      "Set ${1:vVariable} = ${2:value};"
    ],
    "description": "Script statement: SET - assigns a variable value as a literal string (no evaluation)."
  },
  "For Loop": {
    "prefix": "for",
    "body": [
      "For ${1:vI} = ${2:1} to ${3:10}\n\t${4:// loop body}\nNext ${1:vI};"
    ],
    "description": "Script control statement: FOR...NEXT loop."
  },
  "For Each Loop": {
    "prefix": "for each",
    "body": [
      "For Each ${1:vFile} in ${2:FileList('lib://${3:path}/*.qvd')}\n\t${4:// loop body}\nNext ${1:vFile};"
    ],
    "description": "Script control statement: FOR EACH...NEXT loop to iterate over a list."
  },
  "For Each FieldValue Loop": {
    "prefix": "for each fieldvalue",
    "body": [
      "For Each ${1:vValue} in FieldValueList('${2:FieldName}')\n\t${3:// loop body}\nNext ${1:vValue};"
    ],
    "description": "Script control statement: FOR EACH...NEXT loop iterating over field values."
  },
  "Do While Loop": {
    "prefix": "do while",
    "body": [
      "Do While ${1:condition}\n\t${2:// loop body}\nLoop;"
    ],
    "description": "Script control statement: DO WHILE...LOOP."
  },
  "Do Until Loop": {
    "prefix": "do until",
    "body": [
      "Do Until ${1:condition}\n\t${2:// loop body}\nLoop;"
    ],
    "description": "Script control statement: DO UNTIL...LOOP."
  },
  "If Then Else": {
    "prefix": "if",
    "body": [
      "If ${1:condition} Then\n\t${2:// then block}\nElse\n\t${3:// else block}\nEnd If;"
    ],
    "description": "Script control statement: IF...THEN...ELSE...END IF."
  },
  "If Then": {
    "prefix": "if then",
    "body": [
      "If ${1:condition} Then\n\t${2:// then block}\nEnd If;"
    ],
    "description": "Script control statement: IF...THEN...END IF."
  },
  "If Then ElseIf": {
    "prefix": "if elseif",
    "body": [
      "If ${1:condition1} Then\n\t${2:// block 1}\nElseIf ${3:condition2} Then\n\t${4:// block 2}\nElse\n\t${5:// else block}\nEnd If;"
    ],
    "description": "Script control statement: IF...THEN...ELSEIF...ELSE...END IF."
  },
  "Sub": {
    "prefix": "sub",
    "body": [
      "Sub ${1:SubroutineName}(${2:params})\n\t${3:// subroutine body}\nEnd Sub;"
    ],
    "description": "Script control statement: SUB...END SUB - defines a subroutine."
  },
  "Call": {
    "prefix": "call",
    "body": [
      "Call ${1:SubroutineName}(${2:params});"
    ],
    "description": "The call control statement calls a subroutine which must be defined by a previous sub statement."
  },
  "Switch": {
    "prefix": "switch",
    "body": [
      "Switch ${1:expression}\n\tCase ${2:value1}\n\t\t${3:// case 1}\n\tCase ${4:value2}\n\t\t${5:// case 2}\n\tDefault\n\t\t${6:// default}\nEnd Switch;"
    ],
    "description": "Script control statement: SWITCH...CASE...DEFAULT...END SWITCH."
  },
  "Alias": {
    "prefix": "alias",
    "body": [
      "Alias ${1:FieldName} as ${2:AliasName};"
    ],
    "description": "The alias statement is used for setting an alias according to which a field will be renamed whenever it occurs in the script that\nfollows."
  },
  "Binary": {
    "prefix": "binary",
    "body": [
      "Binary ${1:path_to_qvw};"
    ],
    "description": "The binary statement is used for loading the data from another QlikView document, including section access data. It does not load\nthe layout information or variables."
  },
  "Autonumber": {
    "prefix": "autonumber",
    "body": [
      "Autonumber ${1:*};"
    ],
    "description": "Script statement: AUTONUMBER - converts field values to unique integer keys."
  },
  "Comment Table": {
    "prefix": "comment table",
    "body": [
      "Comment Table ${1:TableName} With '${2:Table comment}';"
    ],
    "description": "Script statement: COMMENT TABLE - adds a comment to a table."
  },
  "Comment Field": {
    "prefix": "comment field",
    "body": [
      "Comment Field ${1:FieldName} With '${2:Field comment}';"
    ],
    "description": "Script statement: COMMENT FIELD - adds a comment to a field."
  },
  "Connect": {
    "prefix": "connect",
    "body": [
      "Connect To '${1:connection_string}';"
    ],
    "description": "Script statement: CONNECT - connects to an ODBC/OLEDB data source."
  },
  "LIB Connect": {
    "prefix": "lib connect",
    "body": [
      "LIB Connect To '${1:DataConnectionName}';"
    ],
    "description": "Script statement: LIB CONNECT - connects to a data connection defined in the Qlik Sense library."
  },
  "Concatenate": {
    "prefix": "concatenate",
    "body": [
      "Concatenate (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "If two tables that are to be concatenated have different sets of fields, concatenation of two tables can still be forced with the \nConcatenate prefix. This statement forces concatenation with an existing named table or the latest previously created logical\ntable. An automatic concatenation occurs if two tables have the same field names."
  },
  "NoConcatenate": {
    "prefix": "noconcatenate",
    "body": [
      "NoConcatenate\nLoad\n\t${1:*}\n${2:// source};"
    ],
    "description": "The NoConcatenate prefix forces two loaded tables with identical field sets to be treated as two separate internal tables, when they would otherwise be automatically concatenated."
  },
  "Crosstable": {
    "prefix": "crosstable",
    "body": [
      "Crosstable (${1:AttributeField}, ${2:ValueField}, ${3:2})\nLoad\n\t${4:*}\n${5:// source};"
    ],
    "description": "The crosstable prefix is used to turn a cross table into a straight table, that is, a wide table with many columns is turned into\na tall table, with the column headings being placed into a single attribute column."
  },
  "Directory": {
    "prefix": "directory",
    "body": [
      "Directory ${1:lib://path};"
    ],
    "description": "The Directory statement defines which directory to look in for data files in subsequent LOAD statements, until a new Directory \nstatement is made."
  },
  "Disconnect": {
    "prefix": "disconnect",
    "body": [
      "Disconnect;"
    ],
    "description": "The Disconnect statement terminates the current ODBC/OLE DB/Custom connection. This statement is optional."
  },
  "Drop Table": {
    "prefix": "drop table",
    "body": [
      "Drop Table ${1:TableName};"
    ],
    "description": "One or several QlikView internal tables can be dropped from the data model, and thus from memory, at any time during script\nexecution, by means of a drop table statement."
  },
  "Drop Tables": {
    "prefix": "drop tables",
    "body": [
      "Drop Tables ${1:TableName1}, ${2:TableName2};"
    ],
    "description": "One or several QlikView internal tables can be dropped from the data model, and thus from memory, at any time during script\nexecution, by means of a drop table statement."
  },
  "Drop Field": {
    "prefix": "drop field",
    "body": [
      "Drop Field ${1:FieldName};"
    ],
    "description": "One or several QlikView fields can be dropped from the data model, and thus from memory, at any time during script execution, by\nmeans of a drop field statement."
  },
  "Drop Fields": {
    "prefix": "drop fields",
    "body": [
      "Drop Fields ${1:FieldName1}, ${2:FieldName2};"
    ],
    "description": "One or several QlikView fields can be dropped from the data model, and thus from memory, at any time during script execution, by\nmeans of a drop field statement."
  },
  "Execute": {
    "prefix": "execute",
    "body": [
      "Execute ${1:command};"
    ],
    "description": "The Execute statement is used to run other programs while QlikView is loading data. For example, to make conversions that are\nnecessary."
  },
  "Exit Script": {
    "prefix": "exit script",
    "body": [
      "Exit Script;"
    ],
    "description": "Script control statement: EXIT SCRIPT - stops script execution."
  },
  "FlushLog": {
    "prefix": "flushlog",
    "body": [
      "FlushLog;"
    ],
    "description": "Script statement: FLUSHLOG - forces the script log buffer to be written."
  },
  "Force": {
    "prefix": "force",
    "body": [
      "Force ${1|capitalization,case upper,case lower,case mixed|};"
    ],
    "description": "The force statement forces QlikView to interpret field names and field values of subsequent LOAD and SELECT statements as written\nwith only upper case letters, with only lower case letters, as always capitalized or as they appear (mixed). This statement makes\nit possible to associate field values from tables made according to different conventions."
  },
  "Generic": {
    "prefix": "generic",
    "body": [
      "Generic\nLoad\n\t${1:*}\n${2:// source};"
    ],
    "description": "The generic prefix unpacks a tall table, creating one field per attribute value. This is similar to pivoting a table, except that\nit results in a separate table per field created."
  },
  "Hierarchy": {
    "prefix": "hierarchy",
    "body": [
      "Hierarchy (${1:NodeID}, ${2:ParentID}, ${3:NodeName})\nLoad\n\t${4:*}\n${5:// source};"
    ],
    "description": "The hierarchy prefix is used to transform a parent-child hierarchy table to a table that is useful in a QlikView data model. It\ncan be put in front of a LOAD or a SELECT statement and will use the result of the loading statement as input for a table\ntransformation."
  },
  "HierarchyBelongsTo": {
    "prefix": "hierarchybelongsto",
    "body": [
      "HierarchyBelongsTo (${1:NodeID}, ${2:ParentID}, ${3:NodeName}, ${4:AncestorID}, ${5:AncestorName}, ${6:DepthDiff})\nLoad\n\t${4:*}\n${7:// source};"
    ],
    "description": "This prefix is used to transform a parent-child hierarchy table to a table that is useful in a QlikView data model. It can be put\nin front of a LOAD or a SELECT statement and will use the result of the loading statement as input for a table transformation."
  },
  "IntervalMatch": {
    "prefix": "intervalmatch",
    "body": [
      "IntervalMatch (${1:DateField})\nLoad\n\t${2:StartDate},\n\t${3:EndDate}\nResident ${4:IntervalTable};"
    ],
    "description": "The IntervalMatch prefix is used to create a table matching discrete numeric values to one or more numeric intervals, and\noptionally matching the values of one or several additional keys."
  },
  "Join": {
    "prefix": "join",
    "body": [
      "Join (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "The join prefix joins the loaded table with an existing named table or the last previously created data table."
  },
  "Left Join": {
    "prefix": "left join",
    "body": [
      "Left Join (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "Script prefix: LEFT JOIN - left outer join with an existing named table."
  },
  "Inner Join": {
    "prefix": "inner join",
    "body": [
      "Inner Join (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "Script prefix: INNER JOIN - inner join with an existing named table."
  },
  "Right Join": {
    "prefix": "right join",
    "body": [
      "Inner Join (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "Script prefix: RIGHT JOIN - right outer join with an existing named table."
  },
  "Keep": {
    "prefix": "keep",
    "body": [
      "Keep (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "Script prefix: KEEP - reduces table to the set of common records between two tables."
  },
  "Left Keep": {
    "prefix": "left keep",
    "body": [
      "Left Keep (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "Script prefix: LEFT KEEP - reduces the original table to matching records."
  },
  "Inner Keep": {
    "prefix": "inner keep",
    "body": [
      "Inner Keep (${1:TableName})\nLoad\n\t${2:*}\n${3:// source};"
    ],
    "description": "Script prefix: INNER KEEP - reduces both tables to the intersection."
  },
  "Loosen": {
    "prefix": "loosen table",
    "body": [
      "Loosen Table ${1:TableName};"
    ],
    "description": "Script statement: LOOSEN TABLE - declares a table as loosely coupled."
  },
  "Map Using": {
    "prefix": "map using",
    "body": [
      "Map ${1:FieldName} Using ${2:MapName};"
    ],
    "description": "Script statement: MAP...USING - maps field values using a mapping table."
  },
  "Unmap": {
    "prefix": "unmap",
    "body": [
      "Unmap ${1:FieldName};"
    ],
    "description": "The Unmap statement disables field value mapping specified by a previous Map â€¦ Using statement for subsequently loaded fields."
  },
  "NullAsValue": {
    "prefix": "nullasvalue",
    "body": [
      "NullAsValue ${1:FieldName};"
    ],
    "description": "The NullAsValue statement specifies for which fields that NULL should be converted to a value."
  },
  "NullAsNull": {
    "prefix": "nullasnull",
    "body": [
      "NullAsNull ${1:FieldName};"
    ],
    "description": "The NullAsNull statement turns off the conversion of NULL values to string values previously set by a NullAsValue statement."
  },
  "Qualify": {
    "prefix": "qualify",
    "body": [
      "Qualify ${1:*};"
    ],
    "description": "The Qualify statement is used for switching on the qualification of field names, i.e. field names will get the table name as a\nprefix."
  },
  "Unqualify": {
    "prefix": "unqualify",
    "body": [
      "Unqualify ${1:*};"
    ],
    "description": "The Unqualify statement is used for switching off the qualification of field names that has been previously switched on by the \nQualify statement."
  },
  "Rem": {
    "prefix": "rem",
    "body": [
      "Rem ${1:comment};"
    ],
    "description": "Script statement: REM - adds a remark/comment to the script."
  },
  "Rename Field": {
    "prefix": "rename field",
    "body": [
      "Rename Field ${1:OldName} to ${2:NewName};"
    ],
    "description": "This script function renames one or more existing QlikView field(s) after they have been loaded."
  },
  "Rename Table": {
    "prefix": "rename table",
    "body": [
      "Rename Table ${1:OldName} to ${2:NewName};"
    ],
    "description": "This script function renames one or more existing QlikView internal table(s) after they have been loaded."
  },
  "Section Access": {
    "prefix": "section access",
    "body": [
      "Section Access;"
    ],
    "description": "Script statement: SECTION ACCESS - begins the access control section."
  },
  "Section Application": {
    "prefix": "section application",
    "body": [
      "Section Application;"
    ],
    "description": "Script statement: SECTION APPLICATION - begins the application data section (default)."
  },
  "Sleep": {
    "prefix": "sleep",
    "body": [
      "Sleep ${1:1000};"
    ],
    "description": "Script statement: SLEEP - pauses script execution for the specified milliseconds."
  },
  "SQL": {
    "prefix": "sql",
    "body": [
      "SQL ${1:SELECT * FROM table};"
    ],
    "description": "The SQL statement allows you to send an arbitrary SQL command through anODBC or OLE DB connection."
  },
  "SQLColumns": {
    "prefix": "sqlcolumns",
    "body": [
      "SQLColumns;"
    ],
    "description": "The sqlcolumns statement returns a set of fields describing the columns of an ODBC or OLE DB data source, to which a connect has\nbeen made."
  },
  "SQLTables": {
    "prefix": "sqltables",
    "body": [
      "SQLTables;"
    ],
    "description": "The sqltables statement returns a set of fields describing the tables of an ODBC or OLE DB data source, to which a connect has\nbeen made."
  },
  "SQLTypes": {
    "prefix": "sqltypes",
    "body": [
      "SQLTypes;"
    ],
    "description": "The sqltypes statement returns a set of fields describing the types of an ODBC or OLE DB data source, to which a connect has been\nmade."
  },
  "Star Is": {
    "prefix": "star is",
    "body": [
      "Star Is ${1:*};"
    ],
    "description": "Script statement: STAR IS - sets the representation of the star symbol in the data."
  },
  "Store": {
    "prefix": "store",
    "body": [
      "Store ${1:*} From ${2:TableName} Into [${3:lib://path/file.qvd}] (qvd);"
    ],
    "description": "Script statement: STORE - exports a table to a QVD, CSV, or text file."
  },
  "Store Into QVD": {
    "prefix": "store into qvd",
    "body": [
      "Store ${1:*} From ${2:TableName} Into [${3:lib://path/file.qvd}] (qvd);"
    ],
    "description": "Script statement: STORE INTO QVD - exports a table to a QVD file."
  },
  "Tag Field": {
    "prefix": "tag field",
    "body": [
      "Tag Field ${1:FieldName} With ${2:'$dimension'};"
    ],
    "description": "Script statement: TAG FIELD - applies a tag to a field."
  },
  "Untag Field": {
    "prefix": "untag field",
    "body": [
      "Untag Field ${1:FieldName} With ${2:'$dimension'};"
    ],
    "description": "Script statement: UNTAG FIELD - removes a tag from a field."
  },
  "Trace": {
    "prefix": "trace",
    "body": [
      "Trace ${1:message};"
    ],
    "description": "The trace statement writes a string to the Script Execution Progress window and to the script log file, when used. It is very\nuseful for debugging purposes. Using $-expansions of variables that are calculated prior to the trace statement, you can customize\nthe message."
  },
  "When": {
    "prefix": "when",
    "body": [
      "When ${1:condition}"
    ],
    "description": "The when prefix and suffix is used for creating a conditional clause which determines whether a statement or exit clause should be\nexecuted or not. It may be seen as a compact alternative to the full if..end if statement."
  },
  "Unless": {
    "prefix": "unless",
    "body": [
      "Unless ${1:condition}"
    ],
    "description": "The unless prefix and suffix is used for creating a conditional clause which determines whether a statement or exit clause should\nbe evaluated or not. It may be seen as a compact alternative to the full if..end if statement."
  },
  "Where": {
    "prefix": "where",
    "body": [
      "Where ${1:condition}"
    ],
    "description": "Script clause: WHERE - filters rows during LOAD."
  },
  "Where Exists": {
    "prefix": "where exists",
    "body": [
      "Where Exists(${1:FieldName})"
    ],
    "description": "Script clause: WHERE EXISTS - filters rows based on field value existence."
  },
  "Where Not Exists": {
    "prefix": "where not exists",
    "body": [
      "Where Not Exists(${1:FieldName})"
    ],
    "description": "Script clause: WHERE NOT EXISTS - filters rows where field value does not exist."
  },
  "Group By": {
    "prefix": "group by",
    "body": [
      "Group By ${1:FieldName}"
    ],
    "description": "Script clause: GROUP BY - groups records for aggregation in LOAD."
  },
  "Order By": {
    "prefix": "order by",
    "body": [
      "Order By ${1:FieldName} ${2|asc,desc|}"
    ],
    "description": "Script clause: ORDER BY - sorts the result set in LOAD."
  },
  "Buffer": {
    "prefix": "buffer",
    "body": [
      "Buffer\nLoad\n\t${1:*}\n${2:// source};"
    ],
    "description": "QVD files can be created and maintained automatically via the buffer prefix. This prefix can be used on most LOAD and SELECT \nstatements in script. It indicates that QVD files are used to cache/buffer the result of the statement."
  },
  "Add": {
    "prefix": "add",
    "body": [
      "Add"
    ],
    "description": "The add prefix can be added to any LOAD, SELECT or map...using statement in the script. It is only relevant during partial\nreloads."
  },
  "Replace": {
    "prefix": "replace",
    "body": [
      "Replace(${1:text}, ${2:from_str}, ${3:to_str})"
    ],
    "description": "The replace prefix is used to drop the entire QlikView table and replace it with a new table that is loaded or selected."
  },
  "First": {
    "prefix": "first",
    "body": [
      "First ${1:n}"
    ],
    "description": "The First prefix to a LOAD or SELECT (SQL) statement is used for loading a set maximum number of records from a data source table."
  },
  "Sample": {
    "prefix": "sample",
    "body": [
      "Sample ${1:0.1}"
    ],
    "description": "The sample prefix to a LOAD or SELECT statement is used for loading a random sample of records from the data source."
  },
  "AutoGenerate": {
    "prefix": "autogenerate",
    "body": [
      "Load\n\t${1:RowNo() as ID}\nAutoGenerate(${2:100});"
    ],
    "description": "Script LOAD source: AUTOGENERATE - generates N rows of data."
  },
  "Resident": {
    "prefix": "resident",
    "body": [
      "Resident ${1:TableName}"
    ],
    "description": "Resident LOAD - where you use the Resident predicate in a subsequent LOAD statement to load a new table."
  },
  "Inline": {
    "prefix": "inline",
    "body": [
      "Inline [\n\t${1:Field1}, ${2:Field2}\n\t${3:value1}, ${4:value2}\n]"
    ],
    "description": "Script LOAD source: INLINE - defines data directly in the script."
  },
  "Search Include": {
    "prefix": "search include",
    "body": [
      "Search Include ${1:*};"
    ],
    "description": "Script statement: SEARCH INCLUDE - includes fields in smart search."
  },
  "Search Exclude": {
    "prefix": "search exclude",
    "body": [
      "Search Exclude ${1:FieldName};"
    ],
    "description": "Script statement: SEARCH EXCLUDE - excludes fields from smart search."
  },
  "Declare Field Definition": {
    "prefix": "declare field definition",
    "body": [
      "DECLARE FIELD DEFINITION Tagged ('${1:\\$date}')\n\tFIELDS\n\t\tDual(${2:DayNames}, ${3:Weekday(\\$1)}) AS [${4:Day}] Tagged ('${5:\\$weekday}')\n;"
    ],
    "description": "Script statement: DECLARE FIELD DEFINITION - declares a calendar or derived field definition."
  },
  "Derive Fields": {
    "prefix": "derive fields",
    "body": [
      "DERIVE FIELDS FROM FIELDS [${1:DateField}] USING [${2:CalendarDefinition}];"
    ],
    "description": "Script statement: DERIVE FIELDS - generates derived fields using a field definition."
  },
  "Direct Query": {
    "prefix": "direct query",
    "body": [
      "DIRECT QUERY\n\tDIMENSION ${1:dim_fields}\n\tMEASURE ${2:measure_fields}\nFROM ${3:table_name};"
    ],
    "description": "Script statement: DIRECT QUERY - defines a Direct Discovery query."
  },
  "Create Relationship": {
    "prefix": "create relationship",
    "body": [
      "Create Relationship Between [${1:Table1}] AND [${2:Table2}] ON (${3:Expression});"
    ],
    "description": "Script statement: CREATE RELATIONSHIP - creates an on-demand relationship between tables."
  },
  "Drop Relationship": {
    "prefix": "drop relationship",
    "body": [
      "Drop Relationship Between [${1:Table1}] AND [${2:Table2}];"
    ],
    "description": "Script statement: DROP RELATIONSHIP - removes a relationship between tables."
  },
  "Dimension": {
    "prefix": "dimension",
    "body": [
      "Dimension ${1:vDim} = ${2:expression};"
    ],
    "description": "Script statement: DIMENSION - defines a master dimension variable."
  },
  "Measure": {
    "prefix": "measure",
    "body": [
      "Measure ${1:vMeasure} = ${2:expression};"
    ],
    "description": "Script statement: MEASURE - defines a master measure variable."
  },
  "Acos": {
    "prefix": "acos",
    "body": [
      "Acos(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Acosh": {
    "prefix": "acosh",
    "body": [
      "Acosh(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "AddMonths": {
    "prefix": "addmonths",
    "body": [
      "AddMonths(${1:date}, ${2:no_of_months}, ${3:mode})"
    ],
    "description": "Date and time functions. Returns: dual."
  },
  "AddYears": {
    "prefix": "addyears",
    "body": [
      "AddYears(${1:date}, ${2:no_of_years})"
    ],
    "description": "Date and time functions. Returns: dual."
  },
  "Age": {
    "prefix": "age",
    "body": [
      "Age(${1:timestamp}, ${2:date_of_birth})"
    ],
    "description": "Date and time functions. Returns: integer."
  },
  "Alt": {
    "prefix": "alt",
    "body": [
      "Alt(${1:expr1}, ${2:...})"
    ],
    "description": "Conditional functions. Returns: dual."
  },
  "ApplyCodepage": {
    "prefix": "applycodepage",
    "body": [
      "ApplyCodepage(${1:text}, ${2:codepage})"
    ],
    "description": "String functions. Returns: string."
  },
  "ApplyMap": {
    "prefix": "applymap",
    "body": [
      "ApplyMap(${1:map_id}, ${2:expr}, ${3:default_mapping})"
    ],
    "description": "Mapping functions. Returns: dual."
  },
  "ARGB": {
    "prefix": "argb",
    "body": [
      "ARGB(${1:alpha_value}, ${2:r_value}, ${3:g_value}, ${4:b_value})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "Asin": {
    "prefix": "asin",
    "body": [
      "Asin(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Asinh": {
    "prefix": "asinh",
    "body": [
      "Asinh(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Atan": {
    "prefix": "atan",
    "body": [
      "Atan(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Atan2": {
    "prefix": "atan2",
    "body": [
      "Atan2(${1:y}, ${2:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Atanh": {
    "prefix": "atanh",
    "body": [
      "Atanh(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Attribute": {
    "prefix": "attribute",
    "body": [
      "Attribute(${1:file_name}, ${2:attribute_name})"
    ],
    "description": "File functions. Returns: dual."
  },
  "Author": {
    "prefix": "author",
    "body": [
      "Author()"
    ],
    "description": "System functions. Returns: string."
  },
  "AutoNumber": {
    "prefix": "autonumber(",
    "body": [
      "AutoNumber(${1:expr}, ${2:id})"
    ],
    "description": "Counter functions. AutoNumber(expression) - generates a unique integer for each distinct evaluated value. Returns: integer."
  },
  "AutoNumberHash128": {
    "prefix": "autonumberhash128",
    "body": [
      "AutoNumberHash128(${1:expr}, ${2:...})"
    ],
    "description": "This script function calculates a 128-bit hash of the combined input expression values and the returns a unique integer value for\neach distinct hash value encountered during the script execution. This function can be used for example for creating a compact\nmemory representation of a complex key."
  },
  "AutoNumberHash256": {
    "prefix": "autonumberhash256",
    "body": [
      "AutoNumberHash256(${1:expr}, ${2:...})"
    ],
    "description": "This script function calculates a 256-bit hash of the combined input expression values and returns a unique integer value for each\ndistinct hash value encountered during the script execution. This function can be used e.g. for creating a compact memory\nrepresentation of a complex key."
  },
  "Avg": {
    "prefix": "avg",
    "body": [
      "Avg(${1:expr})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "BetaDensity": {
    "prefix": "betadensity",
    "body": [
      "BetaDensity(${1:value}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "BetaDist": {
    "prefix": "betadist",
    "body": [
      "BetaDist(${1:value}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "BetaInv": {
    "prefix": "betainv",
    "body": [
      "BetaInv(${1:prob}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "BinomDist": {
    "prefix": "binomdist",
    "body": [
      "BinomDist(${1:value}, ${2:trials}, ${3:trial_probability})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "BinomFrequency": {
    "prefix": "binomfrequency",
    "body": [
      "BinomFrequency(${1:value}, ${2:trials}, ${3:trial_probability})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "BinomInv": {
    "prefix": "binominv",
    "body": [
      "BinomInv(${1:prob}, ${2:trials}, ${3:trial_probability})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "BitCount": {
    "prefix": "bitcount",
    "body": [
      "BitCount(${1:integer_number})"
    ],
    "description": "Numeric functions. Returns: integer."
  },
  "Black": {
    "prefix": "black",
    "body": [
      "Black(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "BlackAndSchole": {
    "prefix": "blackandschole",
    "body": [
      "BlackAndSchole(${1:strike}, ${2:time_left}, ${3:underlying}, ${4:vol}, ${5:risk_free_rate}, ${6:call_or_put})"
    ],
    "description": "Financial functions. Returns: number."
  },
  "Blue": {
    "prefix": "blue",
    "body": [
      "Blue(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "Brown": {
    "prefix": "brown",
    "body": [
      "Brown(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "Capitalize": {
    "prefix": "capitalize",
    "body": [
      "Capitalize(${1:text})"
    ],
    "description": "String functions. Returns: string."
  },
  "Ceil": {
    "prefix": "ceil",
    "body": [
      "Ceil(${1:x}, ${2:step}, ${3:offset})"
    ],
    "description": "Numeric functions. Returns: number."
  },
  "Chi2Test_Chi2": {
    "prefix": "chi2test_chi2",
    "body": [
      "Chi2Test_Chi2(${1:col}, ${2:row}, ${3:actual_value}, ${4:expected_value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "Chi2Test_DF": {
    "prefix": "chi2test_df",
    "body": [
      "Chi2Test_DF(${1:col}, ${2:row}, ${3:actual_value}, ${4:expected_value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "Chi2Test_p": {
    "prefix": "chi2test_p",
    "body": [
      "Chi2Test_p(${1:col}, ${2:row}, ${3:actual_value}, ${4:expected_value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ChiDensity": {
    "prefix": "chidensity",
    "body": [
      "ChiDensity(${1:value}, ${2:degrees_freedom})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "ChiDist": {
    "prefix": "chidist",
    "body": [
      "ChiDist(${1:value}, ${2:degrees_freedom})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "ChiInv": {
    "prefix": "chiinv",
    "body": [
      "ChiInv(${1:prob}, ${2:degrees_freedom})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "Chr": {
    "prefix": "chr",
    "body": [
      "Chr(${1:int})"
    ],
    "description": "String functions. Returns: string."
  },
  "Class": {
    "prefix": "class",
    "body": [
      "Class(${1:x}, ${2:class_width}, ${3:formal}, ${4:bias})"
    ],
    "description": "Conditional functions. Returns: string."
  },
  "ClientPlatform": {
    "prefix": "clientplatform",
    "body": [
      "ClientPlatform()"
    ],
    "description": "System functions. Returns: string."
  },
  "Coalesce": {
    "prefix": "coalesce",
    "body": [
      "Coalesce(${1:expr1}, ${2:...})"
    ],
    "description": "Conditional functions. Returns: dual."
  },
  "Color": {
    "prefix": "color",
    "body": [
      "Color(${1:palette_index})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "ColorMapHue": {
    "prefix": "colormaphue",
    "body": [
      "ColorMapHue(${1:ValueBetweenZeroAndOne})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "ColorMapJet": {
    "prefix": "colormapjet",
    "body": [
      "ColorMapJet(${1:ValueBetweenZeroAndOne})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "ColorMix1": {
    "prefix": "colormix1",
    "body": [
      "ColorMix1(${1:ValueBetweenZeroAndOne}, ${2:ColorZero}, ${3:ColorOne})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "ColorMix2": {
    "prefix": "colormix2",
    "body": [
      "ColorMix2(${1:ValueBetweenMinusOneAndOne}, ${2:ColorMinusOne}, ${3:ColorOne}, ${4:ColorZero})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "Combin": {
    "prefix": "combin",
    "body": [
      "Combin(${1:p}, ${2:q})"
    ],
    "description": "Statistical distribution functions. Returns: integer."
  },
  "ComputerName": {
    "prefix": "computername",
    "body": [
      "ComputerName()"
    ],
    "description": "System functions. Returns: string."
  },
  "Concat": {
    "prefix": "concat",
    "body": [
      "Concat(${1:string}, ${2:delimiter}, ${3:sort_weight})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: string."
  },
  "ConnectString": {
    "prefix": "connectstring",
    "body": [
      "ConnectString()"
    ],
    "description": "File functions. Returns: string."
  },
  "ConvertToLocalTime": {
    "prefix": "converttolocaltime",
    "body": [
      "ConvertToLocalTime(${1:timestamp}, ${2:place}, ${3:ignore_dst})"
    ],
    "description": "Date and time functions. Returns: dual."
  },
  "Correl": {
    "prefix": "correl",
    "body": [
      "Correl(${1:value1}, ${2:value2})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "Cos": {
    "prefix": "cos",
    "body": [
      "Cos(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Cosh": {
    "prefix": "cosh",
    "body": [
      "Cosh(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Count": {
    "prefix": "count",
    "body": [
      "Count(${1:expr})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: integer."
  },
  "CountRegEx": {
    "prefix": "countregex",
    "body": [
      "CountRegEx(${1:text}, ${2:regex})"
    ],
    "description": "String functions. Returns: number."
  },
  "CountRegExI": {
    "prefix": "countregexi",
    "body": [
      "CountRegExI(${1:text}, ${2:regex})"
    ],
    "description": "String functions. Returns: number."
  },
  "Cyan": {
    "prefix": "cyan",
    "body": [
      "Cyan(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "DarkGray": {
    "prefix": "darkgray",
    "body": [
      "DarkGray(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "Date": {
    "prefix": "date",
    "body": [
      "Date(${1:number}, ${2:format})"
    ],
    "description": "Interpretation and formatting functions. Returns: dual."
  },
  "Date#": {
    "prefix": "date#",
    "body": [
      "Date#(${1:text}, ${2:format})"
    ],
    "description": "Interpretation and formatting functions. Returns: dual."
  },
  "Day": {
    "prefix": "day",
    "body": [
      "Day(${1:timestamp})"
    ],
    "description": "Date and time functions. Returns: integer."
  },
  "DayEnd": {
    "prefix": "dayend",
    "body": [
      "DayEnd(${1:time}, ${2:period_no}, ${3:day_start})"
    ],
    "description": "Date and time functions. Returns: dual."
  },
  "DaylightSaving": {
    "prefix": "daylightsaving",
    "body": [
      "DaylightSaving()"
    ],
    "description": "Date and time functions. Returns: number."
  },
  "DayName": {
    "prefix": "dayname",
    "body": [
      "DayName(${1:time}, ${2:period_no}, ${3:day_start})"
    ],
    "description": "Date and time functions. Returns: dual."
  },
  "DayNumberOfQuarter": {
    "prefix": "daynumberofquarter",
    "body": [
      "DayNumberOfQuarter(${1:timestamp}, ${2:start_month})"
    ],
    "description": "Date and time functions. Returns: integer."
  },
  "DayNumberOfYear": {
    "prefix": "daynumberofyear",
    "body": [
      "DayNumberOfYear(${1:timestamp}, ${2:start_month})"
    ],
    "description": "Date and time functions. Returns: integer."
  },
  "DayStart": {
    "prefix": "daystart",
    "body": [
      "DayStart(${1:time}, ${2:period_no}, ${3:day_start})"
    ],
    "description": "Date and time functions. Returns: dual."
  },
  "Div": {
    "prefix": "div",
    "body": [
      "Div(${1:integer_number1}, ${2:integer_number2})"
    ],
    "description": "Numeric functions. Returns: integer."
  },
  "DocumentName": {
    "prefix": "documentname",
    "body": [
      "DocumentName()"
    ],
    "description": "This function returns a string containing the name of the current QlikView document, without path but with extension. It can be used in both the load script and in a chart expression."
  },
  "DocumentPath": {
    "prefix": "documentpath",
    "body": [
      "DocumentPath()"
    ],
    "description": "This function returns a string containing the full path to the current QlikView document. It can be used in both the load script and in a chart expression."
  },
  "DocumentTitle": {
    "prefix": "documenttitle",
    "body": [
      "DocumentTitle()"
    ],
    "description": "This function returns a string containing the title of the current QlikView document. It can be used in both the load script and in a chart expression."
  },
  "Dual": {
    "prefix": "dual",
    "body": [
      "Dual(${1:text}, ${2:number})"
    ],
    "description": "Dual() combines a number and a string into a single record, such that the number representation of the record can be used for\nsorting and calculation purposes, while the string value can be used for display purposes"
  },
  "e": {
    "prefix": "e",
    "body": [
      "e()"
    ],
    "description": "Mathematical functions. Returns: number."
  },
  "ElapsedSeconds": {
    "prefix": "elapsedseconds",
    "body": [
      "ElapsedSeconds()"
    ],
    "description": "Date and time functions. Returns: number."
  },
  "EmptyIsNull": {
    "prefix": "emptyisnull",
    "body": [
      "EmptyIsNull(${1:expr1})"
    ],
    "description": "Conditional functions. Returns: dual."
  },
  "EngineVersion": {
    "prefix": "engineversion",
    "body": [
      "EngineVersion()"
    ],
    "description": "System functions. Returns: string."
  },
  "Evaluate": {
    "prefix": "evaluate",
    "body": [
      "Evaluate(${1:expression_text})"
    ],
    "description": "Evaluate() finds if the input text string can be evaluated as a valid QlikView expression, and if so, returns the value of the\nexpression as a string. If the input string is not a valid expression, NULL is returned."
  },
  "Even": {
    "prefix": "even",
    "body": [
      "Even(${1:integer_number})"
    ],
    "description": "Even() returns True (-1), if integer_number is an even integer or zero. It returns False (0), if integer_number is an odd integer,\nand NULL if integer_number is not an integer."
  },
  "Exists": {
    "prefix": "exists",
    "body": [
      "Exists(${1:field_name}, ${2:expr})"
    ],
    "description": "Exists() determines whether a specific field value has already been loaded into the field in the load script. The function returns \nTRUEor FALSE, so can be used in the where clause of a LOADstatement or an IF statement."
  },
  "Exp": {
    "prefix": "exp",
    "body": [
      "Exp(${1:x})"
    ],
    "description": "Exponential and logarithmic functions. Returns: number."
  },
  "ExtractRegEx": {
    "prefix": "extractregex",
    "body": [
      "ExtractRegEx(${1:text}, ${2:regex}, ${3:field_no})"
    ],
    "description": "String functions. Returns: string."
  },
  "ExtractRegExGroup": {
    "prefix": "extractregexgroup",
    "body": [
      "ExtractRegExGroup(${1:text}, ${2:regex}, ${3:group}, ${4:field_no})"
    ],
    "description": "String functions. Returns: string."
  },
  "ExtractRegExGroupI": {
    "prefix": "extractregexgroupi",
    "body": [
      "ExtractRegExGroupI(${1:text}, ${2:regex}, ${3:group}, ${4:field_no})"
    ],
    "description": "String functions. Returns: string."
  },
  "ExtractRegExI": {
    "prefix": "extractregexi",
    "body": [
      "ExtractRegExI(${1:text}, ${2:regex}, ${3:field_no})"
    ],
    "description": "String functions. Returns: string."
  },
  "fAbs": {
    "prefix": "fabs",
    "body": [
      "fAbs(${1:x})"
    ],
    "description": "Numeric functions. Returns: number."
  },
  "Fact": {
    "prefix": "fact",
    "body": [
      "Fact(${1:x})"
    ],
    "description": "Numeric functions. Returns: number."
  },
  "False": {
    "prefix": "false",
    "body": [
      "False()"
    ],
    "description": "Logical functions. Returns: dual."
  },
  "FastMatch": {
    "prefix": "fastmatch",
    "body": [
      "FastMatch(${1:text}, ${2:const_mask_expr1}, ${3:...})"
    ],
    "description": "Conditional functions. Returns: integer."
  },
  "FDensity": {
    "prefix": "fdensity",
    "body": [
      "FDensity(${1:value}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "FDist": {
    "prefix": "fdist",
    "body": [
      "FDist(${1:value}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "FieldElemNo": {
    "prefix": "fieldelemno",
    "body": [
      "FieldElemNo(${1:field_name})"
    ],
    "description": "Table functions. Returns: integer."
  },
  "FieldIndex": {
    "prefix": "fieldindex",
    "body": [
      "FieldIndex(${1:field_name}, ${2:value})"
    ],
    "description": "Returns the position of the field value value found in the field fieldname (by load order). If value cannot be found among the\nfield values, 0 is returned. fieldname must be given as a string value, e.g. the field name must be enclosed by single quotes."
  },
  "FieldName": {
    "prefix": "fieldname",
    "body": [
      "FieldName(${1:field_number}, ${2:table_name})"
    ],
    "description": "The FieldName script function returns the name of the field with the specified number within a previously loaded table. If the\nfunction is used within a LOAD statement, it must not reference the table currently being loaded."
  },
  "FieldNumber": {
    "prefix": "fieldnumber",
    "body": [
      "FieldNumber(${1:field_name}, ${2:table_name})"
    ],
    "description": "The FieldNumber script function returns the number of a specified field within a previously loaded table. If the function is used\nwithin a LOAD statement, it must not reference the table currently being loaded."
  },
  "FieldValue": {
    "prefix": "fieldvalue",
    "body": [
      "FieldValue(${1:field_name}, ${2:elem_no})"
    ],
    "description": "Returns the field value found in position n of the field fieldname (by load order). fieldname must be given as a string value,\ne.g. the field name must be enclosed by single quotes. The first field value is returned for n=1. If n is larger than the number\nof field values, NULL is returned."
  },
  "FieldValueCount": {
    "prefix": "fieldvaluecount",
    "body": [
      "FieldValueCount(${1:field_name})"
    ],
    "description": "This script function returns the number of distinct values in a field. fieldname must be given as a string (for example a quoted\nliteral)."
  },
  "FileBaseName": {
    "prefix": "filebasename",
    "body": [
      "FileBaseName(${1:file_name})"
    ],
    "description": "The FileBaseName function returns a string containing the name of the table file currently being read, without path or extension."
  },
  "FileDir": {
    "prefix": "filedir",
    "body": [
      "FileDir(${1:file_name})"
    ],
    "description": "The FileDir function returns a string containing the path to the directory of the table file currently being read."
  },
  "FileExtension": {
    "prefix": "fileextension",
    "body": [
      "FileExtension(${1:file_name})"
    ],
    "description": "The FileExtension function returns a string containing the extension of the table file currently being read."
  },
  "FileName": {
    "prefix": "filename",
    "body": [
      "FileName(${1:file_name})"
    ],
    "description": "The FileName function returns a string containing the name of the table file currently being read, without path but including the\nextension."
  },
  "FilePath": {
    "prefix": "filepath",
    "body": [
      "FilePath(${1:file_name})"
    ],
    "description": "The FilePath function returns a string containing the full path to the table file currently being read."
  },
  "FileSize": {
    "prefix": "filesize",
    "body": [
      "FileSize(${1:file_name})"
    ],
    "description": "The FileSize function returns an integer containing the size in bytes of the file filename or, if no filename is specified, of the\ntable file currently being read."
  },
  "FileTime": {
    "prefix": "filetime",
    "body": [
      "FileTime(${1:file_name})"
    ],
    "description": "The FileTime function returns a timestamp for the date and time of the last modification of the file filename. If no filename is\nspecified, the function will refer to the currently read table file."
  },
  "FindOneOf": {
    "prefix": "findoneof",
    "body": [
      "FindOneOf(${1:text}, ${2:char_set}, ${3:count})"
    ],
    "description": "FindOneOf() searches a string to find the position of the occurrence of any character from a set of provided characters. The position of the first occurrence of any character from the search set is returned unless a third argument (with a value greater\nthan 1) is supplied. If no match is found, 0 is returned."
  },
  "FInv": {
    "prefix": "finv",
    "body": [
      "FInv(${1:prob}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "FirstSortedValue": {
    "prefix": "firstsortedvalue",
    "body": [
      "FirstSortedValue(${1:value}, ${2:sort_weight}, ${3:rank})"
    ],
    "description": "FirstSortedValue() returns the value from the expression specified in value that corresponds to the result of sorting the \nsort_weight argument, taking into account rank, if specified. If more than one resulting value shares the same sort_weight for the\nspecified rank, the function returns NULL."
  },
  "FirstValue": {
    "prefix": "firstvalue",
    "body": [
      "FirstValue(${1:expr})"
    ],
    "description": "FirstValue() returns the value that was loaded first from the records defined by the expression, sorted by a group by clause."
  },
  "FirstWorkDate": {
    "prefix": "firstworkdate",
    "body": [
      "FirstWorkDate(${1:end_date}, ${2:no_of_workdays}, ${3:holiday}, ${4:...})"
    ],
    "description": "The firstworkdate function returns the latest starting date to achieve no_of_workdays (Monday-Friday) ending no later than \nend_date taking into account any optionally listed holidays. end_date and holiday should be valid dates or timestamps."
  },
  "Floor": {
    "prefix": "floor",
    "body": [
      "Floor(${1:x}, ${2:step}, ${3:offset})"
    ],
    "description": "Floor() rounds x down to the nearest multiple of step [+ offset]. The default value of offset is 0."
  },
  "fMod": {
    "prefix": "fmod",
    "body": [
      "fMod(${1:a}, ${2:b})"
    ],
    "description": "Numeric functions. Returns: number."
  },
  "Frac": {
    "prefix": "frac",
    "body": [
      "Frac(${1:timestamp})"
    ],
    "description": "Frac() returns the fraction to the right of the decimal point of x, where x is a real number."
  },
  "Fractile": {
    "prefix": "fractile",
    "body": [
      "Fractile(${1:expr}, ${2:fraction})"
    ],
    "description": "Fractile() finds the value that corresponds to the fractile (quantile) of the aggregated data in the expression over a number of\nrecords as defined by a group by clause."
  },
  "FractileExc": {
    "prefix": "fractileexc",
    "body": [
      "FractileExc(${1:expr}, ${2:fraction})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "FV": {
    "prefix": "fv",
    "body": [
      "FV(${1:rate}, ${2:nper}, ${3:pmt}, ${4:pv}, ${5:type})"
    ],
    "description": "This function returns the future value of an investment based on periodic, constant payments and a simple annual interest."
  },
  "GammaDensity": {
    "prefix": "gammadensity",
    "body": [
      "GammaDensity(${1:value}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "GammaDist": {
    "prefix": "gammadist",
    "body": [
      "GammaDist(${1:value}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "GammaInv": {
    "prefix": "gammainv",
    "body": [
      "GammaInv(${1:prob}, ${2:degrees_freedom1}, ${3:degrees_freedom2})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "GeoAggrGeometry": {
    "prefix": "geoaggrgeometry",
    "body": [
      "GeoAggrGeometry(${1:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoBoundingBox": {
    "prefix": "geoboundingbox",
    "body": [
      "GeoBoundingBox(${1:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoCountVertex": {
    "prefix": "geocountvertex",
    "body": [
      "GeoCountVertex(${1:field_name})"
    ],
    "description": "Geospatial functions. Returns: integer."
  },
  "GeoGetBoundingBox": {
    "prefix": "geogetboundingbox",
    "body": [
      "GeoGetBoundingBox(${1:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoGetPolygonCenter": {
    "prefix": "geogetpolygoncenter",
    "body": [
      "GeoGetPolygonCenter(${1:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoInvProjectGeometry": {
    "prefix": "geoinvprojectgeometry",
    "body": [
      "GeoInvProjectGeometry(${1:type}, ${2:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoMakePoint": {
    "prefix": "geomakepoint",
    "body": [
      "GeoMakePoint(${1:lat_field_name}, ${2:lon_field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoProject": {
    "prefix": "geoproject",
    "body": [
      "GeoProject(${1:type}, ${2:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoProjectGeometry": {
    "prefix": "geoprojectgeometry",
    "body": [
      "GeoProjectGeometry(${1:type}, ${2:field_name})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GeoReduceGeometry": {
    "prefix": "georeducegeometry",
    "body": [
      "GeoReduceGeometry(${1:field_name}, ${2:value})"
    ],
    "description": "Geospatial functions. Returns: string."
  },
  "GetCollationLocale": {
    "prefix": "getcollationlocale",
    "body": [
      "GetCollationLocale()"
    ],
    "description": "System functions. Returns: string."
  },
  "GetDataModelHash": {
    "prefix": "getdatamodelhash",
    "body": [
      "GetDataModelHash()"
    ],
    "description": "System functions. Returns: string."
  },
  "GetFolderPath": {
    "prefix": "getfolderpath",
    "body": [
      "GetFolderPath(${1:folder})"
    ],
    "description": "The GetFolderPath function returns the value of the Microsoft Windows SHGetFolderPath function. This function takes as input the\nname of a Microsoft Windows folder and returns the full path of the folder."
  },
  "GetObjectField": {
    "prefix": "getobjectfield",
    "body": [
      "GetObjectField(${1:index}, ${2:objectid})"
    ],
    "description": "This function returns the name of the dimension. Index is an optional integer denoting which of the used dimensions that should be\nreturned."
  },
  "GetSysAttr": {
    "prefix": "getsysattr",
    "body": [
      "GetSysAttr(${1:name})"
    ],
    "description": "System functions. Returns: dual."
  },
  "GetUserAttr": {
    "prefix": "getuserattr",
    "body": [
      "GetUserAttr(${1:name})"
    ],
    "description": "System functions. Returns: string."
  },
  "GMT": {
    "prefix": "gmt",
    "body": [
      "GMT(${1:realtime})"
    ],
    "description": "This function returns the date and current Greenwich Mean Time, as derived from the system clock and Windows time settings."
  },
  "Green": {
    "prefix": "green",
    "body": [
      "Green(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "Hash128": {
    "prefix": "hash128",
    "body": [
      "Hash128(${1:expr}, ${2:...})"
    ],
    "description": "Hash128() returns a 128-bit hash of the combined input expression values. The result is a 22-character string."
  },
  "Hash160": {
    "prefix": "hash160",
    "body": [
      "Hash160(${1:expr}, ${2:...})"
    ],
    "description": "Hash160() returns a 160-bit hash of the combined input expression values. The result is a 27-character string."
  },
  "Hash256": {
    "prefix": "hash256",
    "body": [
      "Hash256(${1:expr}, ${2:...})"
    ],
    "description": "Hash256() returns a 256-bit hash of the combined input expression values. The result is a 43-character string."
  },
  "HCNoRows": {
    "prefix": "hcnorows",
    "body": [
      "HCNoRows()"
    ],
    "description": "Table functions. Returns: dual."
  },
  "HCValue": {
    "prefix": "hcvalue",
    "body": [
      "HCValue(${1:fieldname}, ${2:row})"
    ],
    "description": "Record functions. Returns: dual."
  },
  "Hour": {
    "prefix": "hour",
    "body": [
      "Hour(${1:timestamp})"
    ],
    "description": "This function returns an integer representing the hour when the fraction of the expression is interpreted as a time according to\nthe standard number interpretation."
  },
  "HSL": {
    "prefix": "hsl",
    "body": [
      "HSL(${1:hue}, ${2:saturation}, ${3:luminosity})"
    ],
    "description": "HSL() is used in expressions to set or evaluate the color properties of a chart object, where the color is defined by values of \nhue, saturation, and luminosity between 0 and 1."
  },
  "If": {
    "prefix": "if(",
    "body": [
      "If(${1:condition}, ${2:then_expr}, ${3:else_expr})"
    ],
    "description": "Conditional functions. If(condition, then_expr, else_expr) - returns then_expr if condition is true, else_expr otherwise. Returns: dual."
  },
  "InDay": {
    "prefix": "inday",
    "body": [
      "InDay(${1:timestamp}, ${2:base_timestamp}, ${3:period_no}, ${4:day_start})"
    ],
    "description": "This function returns True if timestamp lies inside the day containing base_timestamp."
  },
  "InDayToTime": {
    "prefix": "indaytotime",
    "body": [
      "InDayToTime(${1:timestamp}, ${2:base_timestamp}, ${3:period_no}, ${4:day_start})"
    ],
    "description": "This function returns True if timestamp lies inside the part of day containing base_timestamp up until and including the exact\nmillisecond of base_timestamp."
  },
  "Index": {
    "prefix": "index",
    "body": [
      "Index(${1:text}, ${2:substring}, ${3:count})"
    ],
    "description": "Index() searches a string to find the starting position of the nth occurrence of a provided substring. An optional third argument\nprovides the value of n, which is 1 if omitted. A negative value searches from the end of the string. The positions in the string\nare numbered from 1 and up."
  },
  "IndexRegEx": {
    "prefix": "indexregex",
    "body": [
      "IndexRegEx(${1:text}, ${2:regex}, ${3:count})"
    ],
    "description": "String functions. Returns: integer."
  },
  "IndexRegExGroup": {
    "prefix": "indexregexgroup",
    "body": [
      "IndexRegExGroup(${1:text}, ${2:regex}, ${3:group}, ${4:count})"
    ],
    "description": "String functions. Returns: integer."
  },
  "IndexRegExGroupI": {
    "prefix": "indexregexgroupi",
    "body": [
      "IndexRegExGroupI(${1:text}, ${2:regex}, ${3:group}, ${4:count})"
    ],
    "description": "String functions. Returns: integer."
  },
  "IndexRegExI": {
    "prefix": "indexregexi",
    "body": [
      "IndexRegExI(${1:text}, ${2:regex}, ${3:count})"
    ],
    "description": "String functions. Returns: integer."
  },
  "InLunarWeek": {
    "prefix": "inlunarweek",
    "body": [
      "InLunarWeek(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_week_day})"
    ],
    "description": "This function returns true if timestamp lies inside the lunar week containing base_date. Lunar weeks in QlikView are defined by\ncounting 1 January as the first day of the week."
  },
  "InLunarWeekToDate": {
    "prefix": "inlunarweektodate",
    "body": [
      "InLunarWeekToDate(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_week_day})"
    ],
    "description": "This function returns true if timestamp lies inside the part of the lunar week up to and including the last millisecond of \nbase_date. Lunar weeks in QlikView are defined by counting 1 January as the first day of the week."
  },
  "InMonth": {
    "prefix": "inmonth",
    "body": [
      "InMonth(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns True if timestamp lies inside the month containing base_date."
  },
  "InMonths": {
    "prefix": "inmonths",
    "body": [
      "InMonths(${1:n_months}, ${2:timestamp}, ${3:base_date}, ${4:period_no}, ${5:first_month_of_year})"
    ],
    "description": "This function finds if a timestamp falls within the same month, bi-month, quarter, tertial, or half-year as a base date.It is also\npossible to find if the timestamp falls within a previous or following time period."
  },
  "InMonthsToDate": {
    "prefix": "inmonthstodate",
    "body": [
      "InMonthsToDate(${1:n_months}, ${2:timestamp}, ${3:base_date}, ${4:period_no}, ${5:first_month_of_year})"
    ],
    "description": "This function finds if a timestamp falls within the part of a period of the month, bi-month, quarter, tertial, or half-year up to\nand including the last millisecond of base_date. It is also possible to find if the timestamp falls within a previous or following\ntime period."
  },
  "InMonthToDate": {
    "prefix": "inmonthtodate",
    "body": [
      "InMonthToDate(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "Returns True if timestamp lies inside the part of month containing base_date up until and including the last millisecond of \nbase_date."
  },
  "InQuarter": {
    "prefix": "inquarter",
    "body": [
      "InQuarter(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns True if timestamp lies inside the quarter containing base_date."
  },
  "InQuarterToDate": {
    "prefix": "inquartertodate",
    "body": [
      "InQuarterToDate(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns True if timestamp lies inside the part of the quarter containing base_date up until and including the last\nmillisecond of base_date."
  },
  "Interval": {
    "prefix": "interval",
    "body": [
      "Interval(${1:number}, ${2:format})"
    ],
    "description": "Interval() formats a number as a time interval using the format in the system variables in the load script, or the operating\nsystem, or a format string, if supplied."
  },
  "Interval#": {
    "prefix": "interval#",
    "body": [
      "Interval#(${1:text}, ${2:format})"
    ],
    "description": "Interval#() evaluates a text expression as a time interval in the format set in the operating system, by default, or in the format specified in the second argument, if supplied."
  },
  "InWeek": {
    "prefix": "inweek",
    "body": [
      "InWeek(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_week_day})"
    ],
    "description": "This function returns True if timestamp lies inside the week containing base_date."
  },
  "InWeekToDate": {
    "prefix": "inweektodate",
    "body": [
      "InWeekToDate(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_week_day})"
    ],
    "description": "This function returns True if timestamp lies inside the part of week containing base_date up until and including the last\nmillisecond of base_date."
  },
  "InYear": {
    "prefix": "inyear",
    "body": [
      "InYear(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns True if timestamp lies inside the year containing base_date."
  },
  "InYearToDate": {
    "prefix": "inyeartodate",
    "body": [
      "InYearToDate(${1:timestamp}, ${2:base_date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns True if timestamp lies inside the part of year containing base_date up until and including the last\nmillisecond of base_date."
  },
  "Irr": {
    "prefix": "irr",
    "body": [
      "Irr(${1:value})"
    ],
    "description": "Financial functions. Aggregation function. Returns: number."
  },
  "IsJson": {
    "prefix": "isjson",
    "body": [
      "IsJson(${1:expr}, ${2:type})"
    ],
    "description": "String functions. Returns: boolean."
  },
  "IsNull": {
    "prefix": "isnull",
    "body": [
      "IsNull(${1:expr})"
    ],
    "description": "The IsNull function tests if the value of an expression is NULL and if so, returns -1 (True), otherwise 0 (False)."
  },
  "IsNum": {
    "prefix": "isnum",
    "body": [
      "IsNum(${1:expr})"
    ],
    "description": "Returns -1 (True) if the expression can be interpreted as a number, otherwise 0 (False)."
  },
  "IsPartialReload": {
    "prefix": "ispartialreload",
    "body": [
      "IsPartialReload()"
    ],
    "description": "This function returns - 1 (True) if the current reload is partial, otherwise 0 (False)."
  },
  "IsRegEx": {
    "prefix": "isregex",
    "body": [
      "IsRegEx(${1:expr}, ${2:debug})"
    ],
    "description": "Logical functions. Returns: boolean."
  },
  "IsRegExI": {
    "prefix": "isregexi",
    "body": [
      "IsRegExI(${1:expr}, ${2:debug})"
    ],
    "description": "Logical functions. Returns: boolean."
  },
  "IsText": {
    "prefix": "istext",
    "body": [
      "IsText(${1:expr})"
    ],
    "description": "Returns -1 (True) if the expression has a text representation, otherwise 0 (False)."
  },
  "IterNo": {
    "prefix": "iterno",
    "body": [
      "IterNo()"
    ],
    "description": "This script function returns an integer indicating the current iteration within a while clause. The first iteration has number 1.\nThe IterNo function is only meaningful if used together with a while clause."
  },
  "JsonArray": {
    "prefix": "jsonarray",
    "body": [
      "JsonArray(${1:value}, ${2:sort_weight})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: JSON."
  },
  "JsonGet": {
    "prefix": "jsonget",
    "body": [
      "JsonGet(${1:json}, ${2:path})"
    ],
    "description": "String functions. Returns: value."
  },
  "JsonObject": {
    "prefix": "jsonobject",
    "body": [
      "JsonObject(${1:name}, ${2:value}, ${3:name}, ${4:value}, ${5:...})"
    ],
    "description": "String functions. Returns: JSON."
  },
  "JsonSet": {
    "prefix": "jsonset",
    "body": [
      "JsonSet(${1:json}, ${2:path}, ${3:value}, ${4:...})"
    ],
    "description": "String functions. Returns: JSON."
  },
  "JsonSetEx": {
    "prefix": "jsonsetex",
    "body": [
      "JsonSetEx(${1:json}, ${2:path}, ${3:value}, ${4:...})"
    ],
    "description": "String functions. Returns: JSON."
  },
  "KeepChar": {
    "prefix": "keepchar",
    "body": [
      "KeepChar(${1:text}, ${2:keep_chars})"
    ],
    "description": "KeepChar() returns a string consisting of the first string, 'text', less any of the characters NOT contained in the second string,\n\"keep_chars\"."
  },
  "Kurtosis": {
    "prefix": "kurtosis",
    "body": [
      "Kurtosis(${1:expr})"
    ],
    "description": "Kurtosis() returns the kurtosis of the data in the expression over a number of records as defined by a group by clause."
  },
  "LastValue": {
    "prefix": "lastvalue",
    "body": [
      "LastValue(${1:expr})"
    ],
    "description": "LastValue() returns the value that was loaded last from the records defined by the expression, sorted by a group by clause."
  },
  "LastWorkDate": {
    "prefix": "lastworkdate",
    "body": [
      "LastWorkDate(${1:start_date}, ${2:no_of_workdays}, ${3:holiday}, ${4:...})"
    ],
    "description": "The lastworkdate function returns the earliest ending date to achieve no_of_workdays (Monday-Friday) if starting at start_date \ntaking into account any optionally listed holiday. start_date and holiday should be valid dates or timestamps."
  },
  "Left": {
    "prefix": "left",
    "body": [
      "Left(${1:text}, ${2:count})"
    ],
    "description": "Left() returns a string consisting of the first (left-most) characters of the input string, where the number of characters is determined by the second argument."
  },
  "Len": {
    "prefix": "len",
    "body": [
      "Len(${1:text})"
    ],
    "description": "String functions. Returns: integer."
  },
  "LevenshteinDist": {
    "prefix": "levenshteindist",
    "body": [
      "LevenshteinDist(${1:text1}, ${2:text2})"
    ],
    "description": "String functions. Returns: integer."
  },
  "LightBlue": {
    "prefix": "lightblue",
    "body": [
      "LightBlue(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "LightCyan": {
    "prefix": "lightcyan",
    "body": [
      "LightCyan(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "LightGray": {
    "prefix": "lightgray",
    "body": [
      "LightGray(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "LightGreen": {
    "prefix": "lightgreen",
    "body": [
      "LightGreen(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "LightMagenta": {
    "prefix": "lightmagenta",
    "body": [
      "LightMagenta(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "LightRed": {
    "prefix": "lightred",
    "body": [
      "LightRed(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "LinEst_B": {
    "prefix": "linest_b",
    "body": [
      "LinEst_B(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_DF": {
    "prefix": "linest_df",
    "body": [
      "LinEst_DF(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_F": {
    "prefix": "linest_f",
    "body": [
      "LinEst_F(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_M": {
    "prefix": "linest_m",
    "body": [
      "LinEst_M(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_R2": {
    "prefix": "linest_r2",
    "body": [
      "LinEst_R2(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_SEB": {
    "prefix": "linest_seb",
    "body": [
      "LinEst_SEB(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_SEM": {
    "prefix": "linest_sem",
    "body": [
      "LinEst_SEM(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_SEY": {
    "prefix": "linest_sey",
    "body": [
      "LinEst_SEY(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_SSReg": {
    "prefix": "linest_ssreg",
    "body": [
      "LinEst_SSReg(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LinEst_SSResid": {
    "prefix": "linest_ssresid",
    "body": [
      "LinEst_SSResid(${1:y_value}, ${2:x_value}, ${3:y0_const}, ${4:x0_const})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "LocalTime": {
    "prefix": "localtime",
    "body": [
      "LocalTime(${1:place}, ${2:ignore_dst})"
    ],
    "description": "This function returns a timestamp of the current time from the system clock for a specified time zone."
  },
  "Log": {
    "prefix": "log",
    "body": [
      "Log(${1:x})"
    ],
    "description": "Exponential and logarithmic functions. Returns: number."
  },
  "Log10": {
    "prefix": "log10",
    "body": [
      "Log10(${1:x})"
    ],
    "description": "Exponential and logarithmic functions. Returns: number."
  },
  "Lookup": {
    "prefix": "lookup",
    "body": [
      "Lookup(${1:field_name}, ${2:match_field_name}, ${3:match_field_value}, ${4:table_name})"
    ],
    "description": "Lookup() looks into a table that is already loaded and returns the value of field_name corresponding to the first occurrence of\nthe value match_field_value in the field match_field_name. The table can be the current table or another table previously loaded."
  },
  "Lower": {
    "prefix": "lower",
    "body": [
      "Lower(${1:text})"
    ],
    "description": "Lower() converts all the characters in the input string to lower case."
  },
  "LTrim": {
    "prefix": "ltrim",
    "body": [
      "LTrim(${1:text})"
    ],
    "description": "LTrim() returns the input string trimmed of any leading spaces."
  },
  "LunarWeekEnd": {
    "prefix": "lunarweekend",
    "body": [
      "LunarWeekEnd(${1:date}, ${2:period_no}, ${3:first_week_day})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the last millisecond of the lunar week containing date. Lunar weeks\nin QlikView are defined by counting 1 January as the first day of the week."
  },
  "LunarWeekName": {
    "prefix": "lunarweekname",
    "body": [
      "LunarWeekName(${1:date}, ${2:period_no}, ${3:first_week_day})"
    ],
    "description": "This function returns a display value showing the year and lunar week number corresponding to a timestamp of the first millisecond\nof the first day of the lunar week containing date. Lunar weeks in QlikView are defined by counting 1 January as the first day of\nthe week."
  },
  "LunarWeekStart": {
    "prefix": "lunarweekstart",
    "body": [
      "LunarWeekStart(${1:date}, ${2:period_no}, ${3:first_week_day})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the first millisecond of the lunar week containing date. Lunar weeks\nin QlikView are defined by counting 1 January as the first day of the week."
  },
  "Magenta": {
    "prefix": "magenta",
    "body": [
      "Magenta(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "MakeDate": {
    "prefix": "makedate",
    "body": [
      "MakeDate(${1:year_number}, ${2:month_number}, ${3:day_number})"
    ],
    "description": "This function returns a date calculated from the year YYYY, the month MM and the day DD."
  },
  "MakeTime": {
    "prefix": "maketime",
    "body": [
      "MakeTime(${1:hour}, ${2:minute}, ${3:second})"
    ],
    "description": "This function returns a time calculated from the hour hh, the minute mm, and the second ss."
  },
  "MakeWeekDate": {
    "prefix": "makeweekdate",
    "body": [
      "MakeWeekDate(${1:weekyear_number}, ${2:week_number}, ${3:weekday_number}, ${4:first_week_day}, ${5:broken_weeks}, ${6:reference_day})"
    ],
    "description": "This function returns a date calculated from the year YYYY, the week WW and the day-of-week D."
  },
  "MapSubString": {
    "prefix": "mapsubstring",
    "body": [
      "MapSubString(${1:map_id}, ${2:text})"
    ],
    "description": "The MapSubstring script function is used to map parts of any expression to a previously loaded mapping table. The mapping is case\nsensitive and non-iterative, and substrings are mapped from left to right."
  },
  "Match": {
    "prefix": "match",
    "body": [
      "Match(${1:text}, ${2:mask_expr1}, ${3:...})"
    ],
    "description": "The match function compares the first parameter with all the following ones and returns the number of the expression that matches.\nThe comparison is case sensitive."
  },
  "MatchRegEx": {
    "prefix": "matchregex",
    "body": [
      "MatchRegEx(${1:text}, ${2:regex}, ${3:...})"
    ],
    "description": "Conditional functions. Returns: integer."
  },
  "MatchRegExI": {
    "prefix": "matchregexi",
    "body": [
      "MatchRegExI(${1:text}, ${2:regex}, ${3:...})"
    ],
    "description": "Conditional functions. Returns: integer."
  },
  "Max": {
    "prefix": "max",
    "body": [
      "Max(${1:expr}, ${2:rank})"
    ],
    "description": "Max() finds the highest numeric value of the aggregated data in the expression, as defined by a group by clause. By specifying a \nrank n, the nth highest value can be found."
  },
  "MaxString": {
    "prefix": "maxstring",
    "body": [
      "MaxString(${1:expr})"
    ],
    "description": "MaxString() finds string values in the expression and returns the last text value sorted over a number of records, as defined by a \ngroup by clause."
  },
  "Median": {
    "prefix": "median",
    "body": [
      "Median(${1:expr})"
    ],
    "description": "Syntax: \n\nMedian([{SetExpression}] [DISTINCT] [TOTAL [<fld{, fld}>]] expr) \n\nReturn data type: numeric\n\nArguments: \n\nArgument Description expr The expression or field containing the data to be measured. SetExpression By default, the aggregation\nfunction will aggregate over the set of possible records defined by the selection. An alternative set of records can be defined by\na set analysis expression. DISTINCT If the word DISTINCT occurs before the function arguments, duplicates resulting from the\nevaluation of the function arguments are disregarded. TOTAL If the word TOTAL occurs before the function arguments, the calculation is made over all possible values given the current\nselections, and not just those that pertain to the current dimensional value, that is, it disregards the chart dimensions."
  },
  "Mid": {
    "prefix": "mid",
    "body": [
      "Mid(${1:text}, ${2:start}, ${3:count})"
    ],
    "description": "Mid() returns the part of the input string starting at the position of the character defined by the second argument, 'start', and\nreturning the number of characters defined by the third argument, 'count'. If 'count' is omitted, the rest of the input string is\nreturned. The first character in the input string is numbered 1."
  },
  "Min": {
    "prefix": "min",
    "body": [
      "Min(${1:expr}, ${2:rank})"
    ],
    "description": "Min() returns the lowest numeric value of the aggregated data in the expression, as defined by a group by clause. By specifying a \nrank n, the nth lowest value can be found."
  },
  "MinString": {
    "prefix": "minstring",
    "body": [
      "MinString(${1:expr})"
    ],
    "description": "MaxString() finds string values in the expression and returns the first text value sorted over a number of records, as defined by\na group by clause."
  },
  "Minute": {
    "prefix": "minute",
    "body": [
      "Minute(${1:timestamp})"
    ],
    "description": "This function returns an integer representing the minute when the fraction of the expression is interpreted as a time according to\nthe standard number interpretation."
  },
  "MissingCount": {
    "prefix": "missingcount",
    "body": [
      "MissingCount(${1:expr})"
    ],
    "description": "MissingCount() returns the number of missing values aggregated in the expression, as defined by a group by clause."
  },
  "MixMatch": {
    "prefix": "mixmatch",
    "body": [
      "MixMatch(${1:text}, ${2:mask_expr1}, ${3:...})"
    ],
    "description": "The mixmatch function compares the first parameter with all the following ones and returns the number of the expression that\nmatches. The comparison is case insensitive."
  },
  "Mod": {
    "prefix": "mod",
    "body": [
      "Mod(${1:integer_number1}, ${2:integer_number2})"
    ],
    "description": "Mod() is a modulo function that returns the non-negative remainder of an integer division. The first argument is the dividend, the\nsecond argument is the divisor, Both arguments must be integer values."
  },
  "Mode": {
    "prefix": "mode",
    "body": [
      "Mode(${1:expr})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: dual."
  },
  "Money": {
    "prefix": "money",
    "body": [
      "Money(${1:number}, ${2:format}, ${3:dec_sep}, ${4:thou_sep})"
    ],
    "description": "Money() formats an expression numerically as a money value, in the format set in the system variables set in the load script, or\nin the operating system, unless a format string is supplied, and optional decimal and thousands separators."
  },
  "Money#": {
    "prefix": "money#",
    "body": [
      "Money#(${1:text}, ${2:format}, ${3:dec_sep}, ${4:thou_sep})"
    ],
    "description": "Interpretation and formatting functions. Returns: dual."
  },
  "Month": {
    "prefix": "month",
    "body": [
      "Month(${1:timestamp})"
    ],
    "description": "This function returns a dual value with a month name as defined in the environment variable MonthNames and an integer between\n1-12. The month is calculated from the date interpretation of the expression, according to the standard number interpretation."
  },
  "MonthEnd": {
    "prefix": "monthend",
    "body": [
      "MonthEnd(${1:date}, ${2:period_no})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the last millisecond of the last day of the month containing date.\nThe default output format will be the DateFormat set in the script."
  },
  "MonthName": {
    "prefix": "monthname",
    "body": [
      "MonthName(${1:date}, ${2:period_no})"
    ],
    "description": "This function returns a display value showing the month (formatted according to the MonthNames script variable) and year with an\nunderlying numeric value corresponding to a timestamp of the first millisecond of the first day of the month."
  },
  "MonthsEnd": {
    "prefix": "monthsend",
    "body": [
      "MonthsEnd(${1:n_months}, ${2:date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the last millisecond of the month, bi-month, quarter, tertial, or\nhalf-year containing a base date. It is also possible to find the timestamp for a previous or following time period."
  },
  "MonthsName": {
    "prefix": "monthsname",
    "body": [
      "MonthsName(${1:n_months}, ${2:date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns a display value representing the range of the months of the period (formatted according to the MonthNames \nscript variable) as well as the year. The underlying numeric value corresponds to a timestamp of the first millisecond of the\nmonth, bi-month, quarter, tertial, or half-year containing a base date."
  },
  "MonthsStart": {
    "prefix": "monthsstart",
    "body": [
      "MonthsStart(${1:n_months}, ${2:date}, ${3:period_no}, ${4:first_month_of_year})"
    ],
    "description": "This function returns a value corresponding to the timestamp of the first millisecond of the month, bi-month, quarter, tertial, or\nhalf-year containing a base date. It is also possible to find the timestamp for a previous or following time period."
  },
  "MonthStart": {
    "prefix": "monthstart",
    "body": [
      "MonthStart(${1:date}, ${2:period_no})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the first millisecond of the first day of the month containing date.\nThe default output format will be the DateFormat set in the script."
  },
  "NetWorkDays": {
    "prefix": "networkdays",
    "body": [
      "NetWorkDays(${1:start_date}, ${2:end_date}, ${3:holiday}, ${4:...})"
    ],
    "description": "The networkdays function returns the number of working days (Monday-Friday) between and including start_date and end_date taking\ninto account any optionally listed holiday."
  },
  "NoOfFields": {
    "prefix": "nooffields",
    "body": [
      "NoOfFields(${1:table_name})"
    ],
    "description": "The NoOfFields script function returns the number of fields in a previously loaded table. If the function is used within a LOAD \nstatement, it must not reference the table currently being loaded."
  },
  "NoOfRows": {
    "prefix": "noofrows",
    "body": [
      "NoOfRows(${1:table_name})"
    ],
    "description": "NoOfRows() returns the number of rows in the current column segment in a table. For bitmap charts, NoOfRows() returns the number\nof rows in the chart's straight table equivalent."
  },
  "NoOfTables": {
    "prefix": "nooftables",
    "body": [
      "NoOfTables()"
    ],
    "description": "This script function returns the number of tables previously loaded."
  },
  "NormDist": {
    "prefix": "normdist",
    "body": [
      "NormDist(${1:value}, ${2:mean}, ${3:standard_dev}, ${4:cumulative})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "NormInv": {
    "prefix": "norminv",
    "body": [
      "NormInv(${1:prob}, ${2:mean}, ${3:standard_dev})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "Now": {
    "prefix": "now",
    "body": [
      "Now(${1:timer_mode})"
    ],
    "description": "This function returns a timestamp of the current time from the system clock. The default value is 1."
  },
  "nPer": {
    "prefix": "nper",
    "body": [
      "nPer(${1:rate}, ${2:pmt}, ${3:pv}, ${4:fv}, ${5:type})"
    ],
    "description": "This function returns the number of periods for an investment based on periodic, constant payments and a constant interest rate."
  },
  "Npv": {
    "prefix": "npv",
    "body": [
      "Npv(${1:discount_rate}, ${2:value})"
    ],
    "description": "Financial functions. Aggregation function. Returns: number."
  },
  "Null": {
    "prefix": "null",
    "body": [
      "Null()"
    ],
    "description": "Mathematical functions. Returns: dual."
  },
  "NullCount": {
    "prefix": "nullcount",
    "body": [
      "NullCount(${1:expr})"
    ],
    "description": "NullCount() returns the number of NULL values aggregated in the expression, as defined by a group by clause."
  },
  "Num": {
    "prefix": "num",
    "body": [
      "Num(${1:number}, ${2:format}, ${3:dec_sep}, ${4:thou_sep})"
    ],
    "description": "Num() formats an expression numerically in the number format set in the system variables in the data load script, or in the operating system, unless a format string is supplied, and optional decimal and thousands separators."
  },
  "Num#": {
    "prefix": "num#",
    "body": [
      "Num#(${1:text}, ${2:format}, ${3:dec_sep}, ${4:thou_sep})"
    ],
    "description": "Num#() converts a text string to a numerical value, in the number format set in the load script or the operating system, unless a\nformat string is supplied. Custom decimal and thousand separator symbols are optional parameters."
  },
  "NumAvg": {
    "prefix": "numavg",
    "body": [
      "NumAvg(${1:first_expr}, ${2:...})"
    ],
    "description": "Returns the numeric average of 1 to N arguments. If no numeric value is found, NULL is returned."
  },
  "NumCount": {
    "prefix": "numcount",
    "body": [
      "NumCount(${1:first_expr}, ${2:...})"
    ],
    "description": "Returns the number of numeric values found in 1 to N arguments."
  },
  "NumericCount": {
    "prefix": "numericcount",
    "body": [
      "NumericCount(${1:expr})"
    ],
    "description": "NumericCount() returns the number of numeric values found in the expression, as defined by a group by clause."
  },
  "NumMax": {
    "prefix": "nummax",
    "body": [
      "NumMax(${1:first_expr}, ${2:...})"
    ],
    "description": "Returns the highest numeric value of 1 to N arguments. If no numeric value is found, NULL is returned."
  },
  "NumMin": {
    "prefix": "nummin",
    "body": [
      "NumMin(${1:first_expr}, ${2:...})"
    ],
    "description": "Returns the lowest numeric value of 1 to N arguments. If no numeric value is found, NULL is returned."
  },
  "NumSum": {
    "prefix": "numsum",
    "body": [
      "NumSum(${1:first_expr}, ${2:...})"
    ],
    "description": "Returns the numeric sum of 1 to N arguments. As opposed to the + operator, numsum will treat all non-numeric values as 0."
  },
  "Odd": {
    "prefix": "odd",
    "body": [
      "Odd(${1:integer_number})"
    ],
    "description": "Odd() returns True (-1), if integer_number is an odd integer or zero. It returns False (0), if integer_number is an even integer,\nand NULL if integer_number is not an integer."
  },
  "Only": {
    "prefix": "only",
    "body": [
      "Only(${1:expr})"
    ],
    "description": "Only() returns a value if there is one and only one possible result from the aggregated data. For example, searching for the only\nproduct where the unit price =9 will return NULL if more than one product has a unit price of 9."
  },
  "Ord": {
    "prefix": "ord",
    "body": [
      "Ord(${1:char})"
    ],
    "description": "Ord() returns the Unicode code point number of the first character of the input string."
  },
  "OSUser": {
    "prefix": "osuser",
    "body": [
      "OSUser()"
    ],
    "description": "This function returns a string containing the name of the user that is currently connected. It can be used in both the data load script and in a chart expression."
  },
  "Peek": {
    "prefix": "peek",
    "body": [
      "Peek(${1:field_name}, ${2:row_no}, ${3:table_name})"
    ],
    "description": "Peek() finds the value of a field in a table for a row that has already been loaded or that exists in internal memory. The row\nnumber can be specified, as can the table."
  },
  "Permut": {
    "prefix": "permut",
    "body": [
      "Permut(${1:p}, ${2:q})"
    ],
    "description": "Permut() returns the number of permutations of q elements that can be selected from a set of p items. As represented by the\nformula: Permut(p,q) = (p)! / (p - q)! The order in which the items are selected is significant."
  },
  "Pi": {
    "prefix": "pi",
    "body": [
      "Pi()"
    ],
    "description": "Mathematical functions. Returns: number."
  },
  "Pick": {
    "prefix": "pick",
    "body": [
      "Pick(${1:position}, ${2:...})"
    ],
    "description": "Conditional functions. Returns: dual."
  },
  "Pmt": {
    "prefix": "pmt",
    "body": [
      "Pmt(${1:rate}, ${2:nper}, ${3:pv}, ${4:fv}, ${5:type})"
    ],
    "description": "This function returns the payment for a loan based on periodic, constant payments and a constant interest rate."
  },
  "PoissonDensity": {
    "prefix": "poissondensity",
    "body": [
      "PoissonDensity(${1:value}, ${2:degrees_freedom1})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "PoissonDist": {
    "prefix": "poissondist",
    "body": [
      "PoissonDist(${1:value}, ${2:mean})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "PoissonFrequency": {
    "prefix": "poissonfrequency",
    "body": [
      "PoissonFrequency(${1:value}, ${2:mean})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "PoissonInv": {
    "prefix": "poissoninv",
    "body": [
      "PoissonInv(${1:prob}, ${2:mean})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "Pow": {
    "prefix": "pow",
    "body": [
      "Pow(${1:x}, ${2:y})"
    ],
    "description": "Exponential and logarithmic functions. Returns: number."
  },
  "Previous": {
    "prefix": "previous",
    "body": [
      "Previous(${1:expr})"
    ],
    "description": "Previous() finds the value of the expr expression using data from the previous input record. In the first record of an internal\ntable, the function will return NULL."
  },
  "ProductVersion": {
    "prefix": "productversion",
    "body": [
      "ProductVersion()"
    ],
    "description": "System functions. Returns: string."
  },
  "PurgeChar": {
    "prefix": "purgechar",
    "body": [
      "PurgeChar(${1:text}, ${2:remove_chars})"
    ],
    "description": "PurgeChar() returns a string consisting of the characters contained in the input string ('text'), excluding any that appear in the\nsecond argument ('remove_chars')."
  },
  "PV": {
    "prefix": "pv",
    "body": [
      "PV(${1:rate}, ${2:nper}, ${3:pmt}, ${4:fv}, ${5:type})"
    ],
    "description": "Financial functions. Returns: number."
  },
  "QlikTechBlue": {
    "prefix": "qliktechblue",
    "body": [
      "QlikTechBlue(${1:alpha})"
    ],
    "description": "Legacy functions (deprecated). Returns: integer."
  },
  "QlikTechGray": {
    "prefix": "qliktechgray",
    "body": [
      "QlikTechGray(${1:alpha})"
    ],
    "description": "Legacy functions (deprecated). Returns: integer."
  },
  "QlikViewVersion": {
    "prefix": "qlikviewversion",
    "body": [
      "QlikViewVersion()"
    ],
    "description": "This function returns the full QlikView version and build number as a string."
  },
  "QuarterEnd": {
    "prefix": "quarterend",
    "body": [
      "QuarterEnd(${1:date}, ${2:period_no}, ${3:first_month_of_year})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the last millisecond of the quarter containing date. The default\noutput format will be the DateFormat set in the script."
  },
  "QuarterName": {
    "prefix": "quartername",
    "body": [
      "QuarterName(${1:date}, ${2:period_no}, ${3:first_month_of_year})"
    ],
    "description": "This function returns a display value showing the months of the quarter (formatted according to the MonthNames script variable)\nand year with an underlying numeric value corresponding to a timestamp of the first millisecond of the first day of the quarter."
  },
  "QuarterStart": {
    "prefix": "quarterstart",
    "body": [
      "QuarterStart(${1:date}, ${2:period_no}, ${3:first_month_of_year})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the first millisecond of the quarter containing date. The default\noutput format will be the DateFormat set in the script."
  },
  "QvdCreateTime": {
    "prefix": "qvdcreatetime",
    "body": [
      "QvdCreateTime(${1:qvd_file_name})"
    ],
    "description": "This script function returns the XML-header time stamp from a QVD file, if any is present, otherwise it returns NULL."
  },
  "QvdFieldName": {
    "prefix": "qvdfieldname",
    "body": [
      "QvdFieldName(${1:qvd_file_name}, ${2:field_no})"
    ],
    "description": "This script function returns the name of field number fieldno, if it exists in a QVD file (otherwise NULL)."
  },
  "QvdNoOfFields": {
    "prefix": "qvdnooffields",
    "body": [
      "QvdNoOfFields(${1:qvd_file_name})"
    ],
    "description": "This script function returns the number of fields in a QVD file."
  },
  "QvdNoOfRecords": {
    "prefix": "qvdnoofrecords",
    "body": [
      "QvdNoOfRecords(${1:qvd_file_name})"
    ],
    "description": "This script function returns the number of records currently in a QVD file."
  },
  "QvdTableName": {
    "prefix": "qvdtablename",
    "body": [
      "QvdTableName(${1:qvd_file_name})"
    ],
    "description": "This script function returns the name of the table stored in a QVD file."
  },
  "QVUser": {
    "prefix": "qvuser",
    "body": [
      "QVUser()"
    ],
    "description": "Legacy functions (deprecated). Returns: string."
  },
  "Rand": {
    "prefix": "rand",
    "body": [
      "Rand()"
    ],
    "description": "The function returns a random number between 0 and 1. This can be used to create sample data."
  },
  "RangeAvg": {
    "prefix": "rangeavg",
    "body": [
      "RangeAvg(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeAvg() returns the average of a range. Input to the function can be either a range of values or an expression."
  },
  "RangeCorrel": {
    "prefix": "rangecorrel",
    "body": [
      "RangeCorrel(${1:x_values}, ${2:y_values}, ${3:...})"
    ],
    "description": "Syntax: \n\nRangeCorrel(x_values , y_values[, Expression]) \n\nReturn data type: numeric"
  },
  "RangeCount": {
    "prefix": "rangecount",
    "body": [
      "RangeCount(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeCount()returns the number of values, both text and numeric, in the expression or field."
  },
  "RangeFractile": {
    "prefix": "rangefractile",
    "body": [
      "RangeFractile(${1:fractile}, ${2:first_expr}, ${3:...})"
    ],
    "description": "RangeFractile() returns the value that corresponds to the n-th fractile (quantile) of a range of numbers."
  },
  "RangeFractileExc": {
    "prefix": "rangefractileexc",
    "body": [
      "RangeFractileExc(${1:fractile}, ${2:first_expr}, ${3:...})"
    ],
    "description": "Range functions. Returns: number."
  },
  "RangeIrr": {
    "prefix": "rangeirr",
    "body": [
      "RangeIrr(${1:value}, ${2:value}, ${3:...})"
    ],
    "description": "Financial functions. Returns: number."
  },
  "RangeKurtosis": {
    "prefix": "rangekurtosis",
    "body": [
      "RangeKurtosis(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeKurtosis() returns the value that corresponds to the kurtosis of a range of numbers."
  },
  "RangeMax": {
    "prefix": "rangemax",
    "body": [
      "RangeMax(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeMax() returns the highest numeric value found within the expression or field."
  },
  "RangeMaxString": {
    "prefix": "rangemaxstring",
    "body": [
      "RangeMaxString(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeMaxString() returns the last value in the text sort order that it finds in the expression or field."
  },
  "RangeMin": {
    "prefix": "rangemin",
    "body": [
      "RangeMin(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeMin()returns the lowest numeric values found within the expression or field."
  },
  "RangeMinString": {
    "prefix": "rangeminstring",
    "body": [
      "RangeMinString(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeMinString() returns the first value in the text sort order that it finds in the expression or field."
  },
  "RangeMissingCount": {
    "prefix": "rangemissingcount",
    "body": [
      "RangeMissingCount(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeMissingCount() returns the number of non-numeric values (including NULL) in the expression or field."
  },
  "RangeMode": {
    "prefix": "rangemode",
    "body": [
      "RangeMode(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeMode() finds the most commonly occurring value (mode value) in the expression or field."
  },
  "RangeNpv": {
    "prefix": "rangenpv",
    "body": [
      "RangeNpv(${1:discount_rate}, ${2:value}, ${3:...})"
    ],
    "description": "Financial functions. Returns: number."
  },
  "RangeNullCount": {
    "prefix": "rangenullcount",
    "body": [
      "RangeNullCount(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeNullCount() finds the number of NULLvalues in the expression or field."
  },
  "RangeNumericCount": {
    "prefix": "rangenumericcount",
    "body": [
      "RangeNumericCount(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeNumericCount() finds the number of numeric values in an expression or field."
  },
  "RangeOnly": {
    "prefix": "rangeonly",
    "body": [
      "RangeOnly(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeOnly() is a dual function that returns a value if the expression evaluates to one unique value. If this is not the case then \nNULLis returned."
  },
  "RangeSkew": {
    "prefix": "rangeskew",
    "body": [
      "RangeSkew(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeSkew() returns the value corresponding to the skewness of a range of numbers."
  },
  "RangeStDev": {
    "prefix": "rangestdev",
    "body": [
      "RangeStDev(${1:first_expr}, ${2:...})"
    ],
    "description": "Range functions. Returns: number."
  },
  "RangeSum": {
    "prefix": "rangesum",
    "body": [
      "RangeSum(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeSum() returns the sum of a range of values.All non-numeric values are treated as 0, unlike the + operator."
  },
  "RangeTextCount": {
    "prefix": "rangetextcount",
    "body": [
      "RangeTextCount(${1:first_expr}, ${2:...})"
    ],
    "description": "RangeTextCount() returns the number of text values in an expression or field."
  },
  "RangeXirr": {
    "prefix": "rangexirr",
    "body": [
      "RangeXirr(${1:value}, ${2:date}, ${3:...})"
    ],
    "description": "Financial functions. Returns: number."
  },
  "RangeXnpv": {
    "prefix": "rangexnpv",
    "body": [
      "RangeXnpv(${1:discount_rate}, ${2:value}, ${3:date}, ${4:...})"
    ],
    "description": "Financial functions. Returns: number."
  },
  "Rate": {
    "prefix": "rate",
    "body": [
      "Rate(${1:nper}, ${2:pmt}, ${3:pv}, ${4:fv}, ${5:type})"
    ],
    "description": "This function returns the interest rate per period on annuity. The result has a default number format of Fix two decimals and %."
  },
  "RecNo": {
    "prefix": "recno",
    "body": [
      "RecNo()"
    ],
    "description": "This script functions returns an integer for the number of the currently read row of the current table. The first record is number\n1."
  },
  "Red": {
    "prefix": "red",
    "body": [
      "Red(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "ReloadTime": {
    "prefix": "reloadtime",
    "body": [
      "ReloadTime()"
    ],
    "description": "This function returns a timestamp for when the last data load finished. It can be used in both the data load script and in a chart expression."
  },
  "Repeat": {
    "prefix": "repeat",
    "body": [
      "Repeat(${1:text}, ${2:repeat_count})"
    ],
    "description": "Repeat() forms a string consisting of the input string repeated the number of times defined by the second argument."
  },
  "ReplaceRegEx": {
    "prefix": "replaceregex",
    "body": [
      "ReplaceRegEx(${1:text}, ${2:regex}, ${3:to_str}, ${4:occurrence})"
    ],
    "description": "String functions. Returns: string."
  },
  "ReplaceRegExGroup": {
    "prefix": "replaceregexgroup",
    "body": [
      "ReplaceRegExGroup(${1:text}, ${2:regex}, ${3:to_str}, ${4:group}, ${5:occurrence})"
    ],
    "description": "String functions. Returns: string."
  },
  "ReplaceRegExGroupI": {
    "prefix": "replaceregexgroupi",
    "body": [
      "ReplaceRegExGroupI(${1:text}, ${2:regex}, ${3:to_str}, ${4:group}, ${5:occurrence})"
    ],
    "description": "String functions. Returns: string."
  },
  "ReplaceRegExI": {
    "prefix": "replaceregexi",
    "body": [
      "ReplaceRegExI(${1:text}, ${2:regex}, ${3:to_str}, ${4:occurrence})"
    ],
    "description": "String functions. Returns: string."
  },
  "RGB": {
    "prefix": "rgb",
    "body": [
      "RGB(${1:r_value}, ${2:g_value}, ${3:b_value})"
    ],
    "description": "RGB() is used in expressions to set or evaluate the color properties of a chart object, where the color is defined by a red\ncomponent r, a green component g, and a blue component bwith values between 0 and 255."
  },
  "Right": {
    "prefix": "right",
    "body": [
      "Right(${1:text}, ${2:count})"
    ],
    "description": "Right() returns a string consisting of the of the last (right-most) characters of the input string, where the number of characters is determined by the second argument."
  },
  "Round": {
    "prefix": "round",
    "body": [
      "Round(${1:x}, ${2:step}, ${3:offset})"
    ],
    "description": "Round() returns the result of rounding x up or down to the nearest multiple of step [+ offset]. The default value of offset is 0.\nThe default value of step is 1."
  },
  "RowNo": {
    "prefix": "rowno",
    "body": [
      "RowNo()"
    ],
    "description": "RowNo() returns the number of the current row within the current column segment in a table. For bitmap charts, RowNo()returns the\nnumber of the current row within the chart's straight table equivalent."
  },
  "RTrim": {
    "prefix": "rtrim",
    "body": [
      "RTrim(${1:text})"
    ],
    "description": "RTrim() returns the input string trimmed of any trailing spaces."
  },
  "Second": {
    "prefix": "second",
    "body": [
      "Second(${1:timestamp})"
    ],
    "description": "This function returns an integer representing the second when the fraction of the expression is interpreted as a time according to\nthe standard number interpretation."
  },
  "SetDateYear": {
    "prefix": "setdateyear",
    "body": [
      "SetDateYear(${1:timestamp}, ${2:year})"
    ],
    "description": "This function takes as input a timestamp and a year and updates the timestamp with the year specified in input."
  },
  "SetDateYearMonth": {
    "prefix": "setdateyearmonth",
    "body": [
      "SetDateYearMonth(${1:timestamp}, ${2:year}, ${3:month})"
    ],
    "description": "This function takes as input a timestamp, a month and a year and updates the timestamp with the year and the month specified in\ninput.."
  },
  "Sign": {
    "prefix": "sign",
    "body": [
      "Sign(${1:x})"
    ],
    "description": "gn() returns 1, 0 or -1 depending on whether x is a positive number, 0, or a negative number."
  },
  "Sin": {
    "prefix": "sin",
    "body": [
      "Sin(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Sinh": {
    "prefix": "sinh",
    "body": [
      "Sinh(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Skew": {
    "prefix": "skew",
    "body": [
      "Skew(${1:expr})"
    ],
    "description": "Skew() returns the skewness of expression over a number of records as defined by a group by clause."
  },
  "Sqr": {
    "prefix": "sqr",
    "body": [
      "Sqr(${1:x})"
    ],
    "description": "Exponential and logarithmic functions. Returns: number."
  },
  "Sqrt": {
    "prefix": "sqrt",
    "body": [
      "Sqrt(${1:x})"
    ],
    "description": "Exponential and logarithmic functions. Returns: number."
  },
  "StDev": {
    "prefix": "stdev",
    "body": [
      "StDev(${1:expr})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "StErr": {
    "prefix": "sterr",
    "body": [
      "StErr(${1:expr})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "StEYX": {
    "prefix": "steyx",
    "body": [
      "StEYX(${1:y_value}, ${2:x_value})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "SubField": {
    "prefix": "subfield",
    "body": [
      "SubField(${1:text}, ${2:delimiter}, ${3:field_no})"
    ],
    "description": "Subfield() is used to extract substring components from a parent string field, where the original record fields consist of two or\nmore parts separated by a delimiter."
  },
  "SubFieldRegEx": {
    "prefix": "subfieldregex",
    "body": [
      "SubFieldRegEx(${1:text}, ${2:regex_delimiter}, ${3:field_no})"
    ],
    "description": "String functions. Returns: string."
  },
  "SubFieldRegExI": {
    "prefix": "subfieldregexi",
    "body": [
      "SubFieldRegExI(${1:text}, ${2:regex_delimiter}, ${3:field_no})"
    ],
    "description": "String functions. Returns: string."
  },
  "SubStringCount": {
    "prefix": "substringcount",
    "body": [
      "SubStringCount(${1:text}, ${2:sub_string})"
    ],
    "description": "SubstringCount() returns the number of occurrences of the specified substring in the input string text. If there is no match, 0 is\nreturned."
  },
  "Sum": {
    "prefix": "sum",
    "body": [
      "Sum(${1:expr})"
    ],
    "description": "Aggregation functions. Aggregation function. Returns: number."
  },
  "SysColor": {
    "prefix": "syscolor",
    "body": [
      "SysColor(${1:sys_index})"
    ],
    "description": "SysColor() returns the ARGB color representation for the Windows system color nr, where nr corresponds to the parameter to the Windows API function GetSysColor(nr)."
  },
  "TableName": {
    "prefix": "tablename",
    "body": [
      "TableName(${1:table_number})"
    ],
    "description": "This script function returns the name of the table with the specified number."
  },
  "TableNumber": {
    "prefix": "tablenumber",
    "body": [
      "TableNumber(${1:table_name})"
    ],
    "description": "This script function returns the number of the specified table. The first table has number 0. If table_name does not exist, NULL is returned."
  },
  "Tan": {
    "prefix": "tan",
    "body": [
      "Tan(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "Tanh": {
    "prefix": "tanh",
    "body": [
      "Tanh(${1:x})"
    ],
    "description": "Trigonometric and hyperbolic functions. Returns: number."
  },
  "TDensity": {
    "prefix": "tdensity",
    "body": [
      "TDensity(${1:value}, ${2:degrees_freedom})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "TDist": {
    "prefix": "tdist",
    "body": [
      "TDist(${1:value}, ${2:degrees_freedom}, ${3:tails})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "Text": {
    "prefix": "text",
    "body": [
      "Text(${1:expr})"
    ],
    "description": "ext() forces the expression to be treated as text, even if a numeric interpretation is possible."
  },
  "TextBetween": {
    "prefix": "textbetween",
    "body": [
      "TextBetween(${1:text}, ${2:delimiter1}, ${3:delimiter2}, ${4:count})"
    ],
    "description": "TextBetween() returns the text in the input string that occurs between the characters specified as delimiters."
  },
  "TextCount": {
    "prefix": "textcount",
    "body": [
      "TextCount(${1:expr})"
    ],
    "description": "TextCount() returns the number of field values that are non-numeric aggregated in the expression, as defined by a group by clause."
  },
  "Time": {
    "prefix": "time",
    "body": [
      "Time(${1:number}, ${2:format})"
    ],
    "description": "Interpretation and formatting functions. Returns: dual."
  },
  "Time#": {
    "prefix": "time#",
    "body": [
      "Time#(${1:text}, ${2:format})"
    ],
    "description": "Time#() evaluates an expression as a time value, in the time format set in the data load script or the operating system, unless a format string is supplied.."
  },
  "Timestamp": {
    "prefix": "timestamp",
    "body": [
      "Timestamp(${1:number}, ${2:format})"
    ],
    "description": "TimeStamp() formats an expression as a date and time value, in the timestamp format set in the system variables in the data load script, or in the operating system, unless a format string is supplied."
  },
  "Timestamp#": {
    "prefix": "timestamp#",
    "body": [
      "Timestamp#(${1:text}, ${2:format})"
    ],
    "description": "Timestamp#() evaluates an expression as a date and time value, in the timestamp format set in the load script or the operating\nsystem, unless a format string is supplied."
  },
  "TimeZone": {
    "prefix": "timezone",
    "body": [
      "TimeZone()"
    ],
    "description": "This function returns the name of the current time zone, as defined in Windows, not taking into account the daylight savings\nadjustment."
  },
  "TInv": {
    "prefix": "tinv",
    "body": [
      "TInv(${1:prob}, ${2:degrees_freedom})"
    ],
    "description": "Statistical distribution functions. Returns: number."
  },
  "Today": {
    "prefix": "today",
    "body": [
      "Today(${1:timer_mode})"
    ],
    "description": "This function returns the current date from the system clock."
  },
  "Trim": {
    "prefix": "trim",
    "body": [
      "Trim(${1:text})"
    ],
    "description": "Trim() returns the input string trimmed of any leading and trailing spaces."
  },
  "True": {
    "prefix": "true",
    "body": [
      "True()"
    ],
    "description": "Logical functions. Returns: dual."
  },
  "TTest1_Conf": {
    "prefix": "ttest1_conf",
    "body": [
      "TTest1_Conf(${1:value}, ${2:sig})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_DF": {
    "prefix": "ttest1_df",
    "body": [
      "TTest1_DF(${1:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_Dif": {
    "prefix": "ttest1_dif",
    "body": [
      "TTest1_Dif(${1:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_Lower": {
    "prefix": "ttest1_lower",
    "body": [
      "TTest1_Lower(${1:value}, ${2:sig})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_Sig": {
    "prefix": "ttest1_sig",
    "body": [
      "TTest1_Sig(${1:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_StErr": {
    "prefix": "ttest1_sterr",
    "body": [
      "TTest1_StErr(${1:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_t": {
    "prefix": "ttest1_t",
    "body": [
      "TTest1_t(${1:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1_Upper": {
    "prefix": "ttest1_upper",
    "body": [
      "TTest1_Upper(${1:value}, ${2:sig})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_Conf": {
    "prefix": "ttest1w_conf",
    "body": [
      "TTest1w_Conf(${1:weight}, ${2:value}, ${3:sig}, ${4:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_DF": {
    "prefix": "ttest1w_df",
    "body": [
      "TTest1w_DF(${1:weight}, ${2:value}, ${3:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_Dif": {
    "prefix": "ttest1w_dif",
    "body": [
      "TTest1w_Dif(${1:weight}, ${2:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_Lower": {
    "prefix": "ttest1w_lower",
    "body": [
      "TTest1w_Lower(${1:weight}, ${2:value}, ${3:sig}, ${4:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_Sig": {
    "prefix": "ttest1w_sig",
    "body": [
      "TTest1w_Sig(${1:weight}, ${2:value}, ${3:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_StErr": {
    "prefix": "ttest1w_sterr",
    "body": [
      "TTest1w_StErr(${1:weight}, ${2:value}, ${3:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_t": {
    "prefix": "ttest1w_t",
    "body": [
      "TTest1w_t(${1:weight}, ${2:value}, ${3:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest1w_Upper": {
    "prefix": "ttest1w_upper",
    "body": [
      "TTest1w_Upper(${1:weight}, ${2:value}, ${3:sig}, ${4:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_Conf": {
    "prefix": "ttest_conf",
    "body": [
      "TTest_Conf(${1:grp}, ${2:value}, ${3:sig}, ${4:eq_var})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_DF": {
    "prefix": "ttest_df",
    "body": [
      "TTest_DF(${1:grp}, ${2:value}, ${3:eq_var})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_Dif": {
    "prefix": "ttest_dif",
    "body": [
      "TTest_Dif(${1:grp}, ${2:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_Lower": {
    "prefix": "ttest_lower",
    "body": [
      "TTest_Lower(${1:grp}, ${2:value}, ${3:sig}, ${4:eq_var})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_Sig": {
    "prefix": "ttest_sig",
    "body": [
      "TTest_Sig(${1:grp}, ${2:value}, ${3:eq_var})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_StErr": {
    "prefix": "ttest_sterr",
    "body": [
      "TTest_StErr(${1:grp}, ${2:value}, ${3:eq_var})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTest_t": {
    "prefix": "ttest_t",
    "body": [
      "TTest_t(${1:grp}, ${2:value}, ${3:eq_var})"
    ],
    "description": "TTest_t() returns the aggregated t value for two independent series of values."
  },
  "TTest_Upper": {
    "prefix": "ttest_upper",
    "body": [
      "TTest_Upper(${1:grp}, ${2:value}, ${3:sig}, ${4:eq_var})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_Conf": {
    "prefix": "ttestw_conf",
    "body": [
      "TTestw_Conf(${1:weight}, ${2:grp}, ${3:value}, ${4:sig}, ${5:eq_var}, ${6:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_DF": {
    "prefix": "ttestw_df",
    "body": [
      "TTestw_DF(${1:weight}, ${2:grp}, ${3:value}, ${4:eq_var}, ${5:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_Dif": {
    "prefix": "ttestw_dif",
    "body": [
      "TTestw_Dif(${1:weight}, ${2:grp}, ${3:value})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_Lower": {
    "prefix": "ttestw_lower",
    "body": [
      "TTestw_Lower(${1:weight}, ${2:grp}, ${3:value}, ${4:sig}, ${5:eq_var}, ${6:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_Sig": {
    "prefix": "ttestw_sig",
    "body": [
      "TTestw_Sig(${1:weight}, ${2:grp}, ${3:value}, ${4:eq_var}, ${5:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_StErr": {
    "prefix": "ttestw_sterr",
    "body": [
      "TTestw_StErr(${1:weight}, ${2:grp}, ${3:value}, ${4:eq_var}, ${5:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "TTestw_t": {
    "prefix": "ttestw_t",
    "body": [
      "TTestw_t(${1:weight}, ${2:grp}, ${3:value}, ${4:eq_var}, ${5:weight_type})"
    ],
    "description": "TTestw_t() returns the aggregated t value for two independent series of values."
  },
  "TTestw_Upper": {
    "prefix": "ttestw_upper",
    "body": [
      "TTestw_Upper(${1:weight}, ${2:grp}, ${3:value}, ${4:sig}, ${5:eq_var}, ${6:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "UNBOUNDED": {
    "prefix": "unbounded",
    "body": [
      "UNBOUNDED()"
    ],
    "description": "Window functions. Returns: integer."
  },
  "Upper": {
    "prefix": "upper",
    "body": [
      "Upper(${1:text})"
    ],
    "description": "Upper() converts all the characters in the input string to upper case for all text characters in the expression. Numbers and\nsymbols are ignored."
  },
  "UTC": {
    "prefix": "utc",
    "body": [
      "UTC(${1:realtime})"
    ],
    "description": "Date and time functions. Returns: number."
  },
  "Week": {
    "prefix": "week",
    "body": [
      "Week(${1:timestamp}, ${2:first_week_day}, ${3:broken_weeks}, ${4:reference_day})"
    ],
    "description": "Date and time functions. Returns: integer."
  },
  "WeekDay": {
    "prefix": "weekday",
    "body": [
      "WeekDay(${1:timestamp}, ${2:first_week_day})"
    ],
    "description": "Date and time functions. Returns: integer."
  },
  "WeekEnd": {
    "prefix": "weekend",
    "body": [
      "WeekEnd(${1:date}, ${2:period_no}, ${3:first_week_day})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the last millisecond of the last day (Sunday) of the calendar week\ncontaining date The default output format will be the DateFormat set in the script."
  },
  "WeekName": {
    "prefix": "weekname",
    "body": [
      "WeekName(${1:date}, ${2:period_no}, ${3:first_week_day}, ${4:broken_weeks}, ${5:reference_day})"
    ],
    "description": "This function returns a value showing the year and week number with an underlying numeric value corresponding to a timestamp of\nthe first millisecond of the first day of the week containing date."
  },
  "WeekStart": {
    "prefix": "weekstart",
    "body": [
      "WeekStart(${1:date}, ${2:period_no}, ${3:first_week_day})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the first millisecond of the first day (Monday) of the calendar week\ncontaining date. The default output format is the DateFormat set in the script."
  },
  "WeekYear": {
    "prefix": "weekyear",
    "body": [
      "WeekYear(${1:timestamp}, ${2:first_week_day}, ${3:broken_weeks}, ${4:reference_day})"
    ],
    "description": "This function returns the year to which the week number belongs according to ISO 8601. The week number ranges between 1 and\napproximately 52."
  },
  "White": {
    "prefix": "white",
    "body": [
      "White(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "WildMatch": {
    "prefix": "wildmatch",
    "body": [
      "WildMatch(${1:text}, ${2:mask_expr1}, ${3:...})"
    ],
    "description": "The wildmatch function compares the first parameter with all the following ones and returns the number of expression that matches.\nIt permits the use of wildcard characters ( * and ?) in the comparison strings. The comparison is case insensitive."
  },
  "Window": {
    "prefix": "window",
    "body": [
      "Window(${1:input_expr}, ${2:partition}, ${3:...})"
    ],
    "description": "Window functions. Returns: dual."
  },
  "WRank": {
    "prefix": "wrank",
    "body": [
      "WRank(${1:mode}, ${2:fmt})"
    ],
    "description": "Window functions. Returns: dual."
  },
  "Xirr": {
    "prefix": "xirr",
    "body": [
      "Xirr(${1:pmt}, ${2:date}, ${3:hint})"
    ],
    "description": "Financial functions. Aggregation function. Returns: number."
  },
  "Xnpv": {
    "prefix": "xnpv",
    "body": [
      "Xnpv(${1:discount_rate}, ${2:pmt}, ${3:date})"
    ],
    "description": "Financial functions. Aggregation function. Returns: number."
  },
  "Year": {
    "prefix": "year",
    "body": [
      "Year(${1:timestamp})"
    ],
    "description": "This function returns an integer representing the year when the expression is interpreted as a date according to the standard\nnumber interpretation."
  },
  "Year2Date": {
    "prefix": "year2date",
    "body": [
      "Year2Date(${1:timestamp}, ${2:year_offset}, ${3:start_month}, ${4:ref_timestamp})"
    ],
    "description": "Date and time functions. Returns: boolean."
  },
  "YearEnd": {
    "prefix": "yearend",
    "body": [
      "YearEnd(${1:date}, ${2:period_no}, ${3:first_month_of_year})"
    ],
    "description": "This function returns a value corresponding to a timestamp of the last millisecond of the last day of the year containing date.\nThe default output format will be the DateFormat set in the script."
  },
  "YearName": {
    "prefix": "yearname",
    "body": [
      "YearName(${1:date}, ${2:period_no}, ${3:first_month_of_year})"
    ],
    "description": "This function returns a four-digit year as display value with an underlying numeric value corresponding to a timestamp of the\nfirst millisecond of the first day of the year containing date."
  },
  "YearStart": {
    "prefix": "yearstart",
    "body": [
      "YearStart(${1:date}, ${2:period_no}, ${3:first_month_of_year})"
    ],
    "description": "This function returns a timestamp corresponding to the start of the first day of the year containing date. The default output\nformat will be the DateFormat set in the script."
  },
  "YearToDate": {
    "prefix": "yeartodate",
    "body": [
      "YearToDate(${1:timestamp}, ${2:year_offset}, ${3:start_month}, ${4:ref_timestamp})"
    ],
    "description": "This function finds if the input date falls within the year of the date the script was last loaded, and returns True if it does, \nFalse if it does not."
  },
  "Yellow": {
    "prefix": "yellow",
    "body": [
      "Yellow(${1:alpha})"
    ],
    "description": "Color functions. Returns: integer."
  },
  "ZTest_Conf": {
    "prefix": "ztest_conf",
    "body": [
      "ZTest_Conf(${1:value}, ${2:sigma}, ${3:sig})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTest_Dif": {
    "prefix": "ztest_dif",
    "body": [
      "ZTest_Dif(${1:value}, ${2:sigma})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTest_Lower": {
    "prefix": "ztest_lower",
    "body": [
      "ZTest_Lower(${1:value}, ${2:sigma}, ${3:sig})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTest_Sig": {
    "prefix": "ztest_sig",
    "body": [
      "ZTest_Sig(${1:value}, ${2:sigma})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTest_StErr": {
    "prefix": "ztest_sterr",
    "body": [
      "ZTest_StErr(${1:value}, ${2:sigma})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTest_Upper": {
    "prefix": "ztest_upper",
    "body": [
      "ZTest_Upper(${1:value}, ${2:sigma}, ${3:sig})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTest_z": {
    "prefix": "ztest_z",
    "body": [
      "ZTest_z(${1:value}, ${2:sigma})"
    ],
    "description": "This script function returns the aggregated z value for a series of values iterated over a number of records as defined by a group\nby clause."
  },
  "ZTestw_Conf": {
    "prefix": "ztestw_conf",
    "body": [
      "ZTestw_Conf(${1:weight}, ${2:value}, ${3:sigma}, ${4:sig}, ${5:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTestw_Dif": {
    "prefix": "ztestw_dif",
    "body": [
      "ZTestw_Dif(${1:weight}, ${2:value}, ${3:sigma})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTestw_Lower": {
    "prefix": "ztestw_lower",
    "body": [
      "ZTestw_Lower(${1:weight}, ${2:value}, ${3:sigma}, ${4:sig}, ${5:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTestw_Sig": {
    "prefix": "ztestw_sig",
    "body": [
      "ZTestw_Sig(${1:weight}, ${2:value}, ${3:sigma}, ${4:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTestw_StErr": {
    "prefix": "ztestw_sterr",
    "body": [
      "ZTestw_StErr(${1:weight}, ${2:value}, ${3:sigma}, ${4:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTestw_Upper": {
    "prefix": "ztestw_upper",
    "body": [
      "ZTestw_Upper(${1:weight}, ${2:value}, ${3:sigma}, ${4:sig}, ${5:weight_type})"
    ],
    "description": "Statistical distribution functions. Aggregation function. Returns: number."
  },
  "ZTestw_z": {
    "prefix": "ztestw_z",
    "body": [
      "ZTestw_z(${1:weight}, ${2:value}, ${3:sigma}, ${4:weight_type})"
    ],
    "description": "This script function returns the aggregated z value for a series of values iterated over a number of records as defined by a group\nby clause."
  },
  "Comment": {
    "prefix": "comment",
    "body": [
      "Comment ${1|Table,Tables,Field,Fields|} ${2:Name} With '${3:comment}';"
    ],
    "description": "Script statement: COMMENT - adds a comment to tables or fields."
  },
  "Load distinct": {
    "prefix": "load distinct",
    "body": [
      "Load Distinct\n\t${1:*}\n${2:// source};"
    ],
    "description": "Script statement: LOAD DISTINCT - loads only unique records."
  },
  "InputField": {
    "prefix": "inputfield fieldlist",
    "body": [
      "InputField ${1:FieldName};\n"
    ],
    "description": "[#]  INPUTFIELD\nA field may be flagged as an input field by listing it in an inputfield statement before it is referenced in any LOAD or SELECT \nstatements."
  },
  "Map": {
    "prefix": "Map *fieldlist Using  mapname",
    "body": [
      "Map"
    ],
    "description": "The map ... using statement is used for mapping a certain field value or expression to the values of a specific mapping table. The\nmapping table is created through the Mapping statement."
  },
  "Rename Field Using": {
    "prefix": "rename field using",
    "body": [
      "Rename Field Using ${1:MappingTable};"
    ],
    "description": "Script statement: RENAME FIELD USING - renames fields using a mapping table."
  },
  "Rename Tables": {
    "prefix": "rename tables",
    "body": [
      "Rename Tables Using ${1:MappingTable};"
    ],
    "description": "Script statement: RENAME TABLES USING - renames tables using a mapping table."
  },
  "Section": {
    "prefix": "Section (access | application)",
    "body": [
      "Section"
    ],
    "description": "With the section statement, it is possible to define whether the subsequent LOAD and SELECT statements should be considered as\ndata or as a definition of the access rights."
  },
  "Semantic": {
    "prefix": "Semantic( loadstatement | selectstatement)",
    "body": [
      "Semantic"
    ],
    "description": "Tables containing relations between records can be loaded through a semantic prefix. This can for example be self-references\nwithin a table, where one record points to another, such as parent, belongs to, or predecessor."
  },
  "Star": {
    "prefix": "Star is[ string ]",
    "body": [
      "Star is ${1:*};"
    ],
    "description": "The string used for representing the set of all the values of a field in the database can be set through the star statement. It\naffects the subsequent LOAD and SELECT statements."
  },
  "Tag fields": {
    "prefix": "Tag fields fieldlist using mapname",
    "body": [
      "Tag fields"
    ],
    "description": "This script function provides a way of assigning tags to one or more fields. If an attempt to tag a field name not present in the app is made, the tagging will be ignored. If conflicting occurrences of a field or tag name are found, the last value is used."
  },
  "Untag fields": {
    "prefix": "Untag fields fieldlist using mapname",
    "body": [
      "Untag fields"
    ],
    "description": "Provides a way of removing tags from one or more fields. If an attempt to untag a Field name not present in the document is made,\nthe untagging will be ignored. If conflicting occurrences of a field or tag name is found, the last value is used."
  },
  "step": {
    "prefix": "step",
    "body": [
      "Step ${1:increment}"
    ],
    "description": "Script keyword: STEP - specifies the increment in a FOR loop."
  },
  "FileList": {
    "prefix": "FileList",
    "body": [
      "FileList"
    ],
    "description": ""
  },
  "GetExtendedProperty": {
    "prefix": "GetExtendedProperty (name[, objectid])",
    "body": [
      "GetExtendedProperty()"
    ],
    "description": "This function returns the value of a named extended property in the sheet object with the given object ID. If objectid is not\ngiven, the sheet object containing the expression will be used. An extended property is defined for the extension object in its\ndefinition file."
  },
  "GetRegistryString": {
    "prefix": "getregistrystring",
    "body": [
      "GetRegistryString(${1:path}, ${2:key})"
    ],
    "description": "System functions. Returns: string. Deprecated."
  },
  "Input": {
    "prefix": "Input",
    "body": [
      "Input"
    ],
    "description": ""
  },
  "InputAvg": {
    "prefix": "InputAvg",
    "body": [
      "InputAvg"
    ],
    "description": "inputavg() returns the aggregated average of inputfield iterated over the chart dimension(s). inputfield must be a field name of a\nfield properly declared as an input field in the script."
  },
  "InputSum": {
    "prefix": "InputSum",
    "body": [
      "InputSum"
    ],
    "description": "inputsum() returns the aggregated sum of inputfield iterated over the chart dimension(s). inputfield must be a field name of a\nfield properly declared as an input field in the script."
  },
  "MsgBox": {
    "prefix": "msgbox",
    "body": [
      "MsgBox(${1:message})"
    ],
    "description": "System functions. Returns: dual. QlikView only."
  },
  "HidePrefix": {
    "prefix": "HidePrefix",
    "body": [
      "HidePrefix()"
    ],
    "description": "All field names beginning with this text string will be hidden in the same manner as the system fields. This is a user-defined\nvariable."
  },
  "HideSuffix": {
    "prefix": "HideSuffix",
    "body": [
      "HideSuffix()"
    ],
    "description": "All field names ending with this text string will be hidden in the same manner as the system fields. This is a user-defined\nvariable."
  }
}